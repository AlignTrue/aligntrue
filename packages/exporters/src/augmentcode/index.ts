/**
 * AugmentCode exporter
 * Exports AlignTrue rules to AugmentCode .augment/rules/ directory format
 */

import { join } from 'path'
import type { ExporterPlugin, ScopedExportRequest, ExportOptions, ExportResult, ResolvedScope } from '../types.js'
import type { AlignRule } from '@aligntrue/schema'
import { canonicalizeJson, computeHash } from '@aligntrue/schema'
import { AtomicFileWriter } from '@aligntrue/file-utils'

export class AugmentCodeExporter implements ExporterPlugin {
  name = 'augmentcode'
  version = '1.0.0'
  
  async export(request: ScopedExportRequest, options: ExportOptions): Promise<ExportResult> {
    const { scope, rules } = request
    const { outputDir, dryRun = false } = options

    if (!rules || rules.length === 0) {
      throw new Error('AugmentCodeExporter requires at least one rule to export')
    }

    const filename = this.getScopeFilename(scope)
    const outputPath = join(outputDir, '.augment', 'rules', filename)

    const content = this.generateRuleContent(scope, rules)

    const irContent = JSON.stringify({ scope, rules })
    const contentHash = computeHash(canonicalizeJson(irContent))

    const fidelityNotes = this.computeFidelityNotes(rules)

    if (!dryRun) {
      const writer = new AtomicFileWriter()
      writer.write(outputPath, content)
    }

    const result: ExportResult = {
      success: true,
      filesWritten: dryRun ? [] : [outputPath],
      contentHash,
    }

    if (fidelityNotes.length > 0) {
      result.fidelityNotes = fidelityNotes
    }

    return result
  }

  private getScopeFilename(scope: ResolvedScope): string {
    if (scope.isDefault || scope.path === '.' || scope.path === '') {
      return 'rules.md'
    }

    const normalized = scope.normalizedPath.replace(/\//g, '-')
    return `${normalized}.md`
  }

  private generateRuleContent(scope: ResolvedScope, rules: AlignRule[]): string {
    const lines: string[] = []
    
    const scopeDesc = scope.isDefault 
      ? 'AugmentCode rules (default scope)' 
      : `AugmentCode rules for ${scope.path}`
    lines.push(`# ${scopeDesc}`)
    lines.push('')

    rules.forEach(rule => {
      lines.push(`## Rule: ${rule.id}`)
      lines.push('')
      lines.push(`**Severity:** ${rule.severity}`)
      lines.push('')

      if (rule.applies_to && rule.applies_to.length > 0) {
        lines.push(`**Applies to:**`)
        rule.applies_to.forEach(pattern => {
          lines.push(`- \`${pattern}\``)
        })
        lines.push('')
      }

      if (rule.guidance) {
        lines.push(rule.guidance.trim())
        lines.push('')
      }
    })

    const irContent = JSON.stringify({ scope, rules })
    const contentHash = computeHash(canonicalizeJson(irContent))
    const fidelityNotes = this.computeFidelityNotes(rules)

    lines.push('---')
    lines.push('')
    lines.push('**Generated by AlignTrue**')
    lines.push(`Content Hash: ${contentHash}`)

    if (fidelityNotes.length > 0) {
      lines.push('')
      lines.push('**Fidelity Notes:**')
      fidelityNotes.forEach(note => {
        lines.push(`- ${note}`)
      })
    }

    lines.push('')
    return lines.join('\n')
  }

  private computeFidelityNotes(rules: AlignRule[]): string[] {
    const notes: string[] = []
    const unmappedFields = new Set<string>()

    rules.forEach(rule => {
      if (rule.check) {
        unmappedFields.add('check')
      }
      if (rule.autofix) {
        unmappedFields.add('autofix')
      }
    })

    if (unmappedFields.has('check')) {
      notes.push('Machine-checkable rules (check) not represented in .augment/rules/ format')
    }
    if (unmappedFields.has('autofix')) {
      notes.push('Autofix hints not represented in .augment/rules/ format')
    }

    notes.push('applies_to patterns preserved in metadata but not enforced by AugmentCode')

    return notes
  }
}

export default AugmentCodeExporter

