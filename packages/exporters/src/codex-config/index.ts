/**
 * OpenAI Codex CLI Config exporter
 * Exports AlignTrue rules to .codex/config.toml format
 *
 * Note: Currently exports as JSON. TOML support requires @iarna/toml package.
 */

import { join, dirname } from "path";
import { mkdirSync } from "fs";
import type {
  ExporterPlugin,
  ScopedExportRequest,
  ExportOptions,
  ExportResult,
} from "../types.js";
import type { AlignRule } from "@aligntrue/schema";
import { canonicalizeJson, computeHash } from "@aligntrue/schema";
import { AtomicFileWriter } from "@aligntrue/file-utils";

interface ExporterState {
  allRules: Array<{ rule: AlignRule; scopePath: string }>;
}

export class CodexConfigExporter implements ExporterPlugin {
  name = "codex-config";
  version = "1.0.0";

  private state: ExporterState = {
    allRules: [],
  };

  async export(
    request: ScopedExportRequest,
    options: ExportOptions,
  ): Promise<ExportResult> {
    const { scope, rules } = request;
    const { outputDir, dryRun = false } = options;

    if (!rules || rules.length === 0) {
      return { success: true, filesWritten: [], contentHash: "" };
    }

    const scopePath =
      scope.isDefault || scope.path === "." || scope.path === ""
        ? "all files"
        : scope.path;
    rules.forEach((rule) => this.state.allRules.push({ rule, scopePath }));

    const outputPath = join(outputDir, ".codex", "config.toml");

    // Simple TOML-like format
    const content = this.generateTomlContent(options.unresolvedPlugsCount);
    const contentHash = computeHash(
      canonicalizeJson(
        JSON.stringify({ rules: this.state.allRules.map(({ rule }) => rule) }),
      ),
    );

    if (!dryRun) {
      mkdirSync(dirname(outputPath), { recursive: true });
      new AtomicFileWriter().write(outputPath, content);
    }

    return {
      success: true,
      filesWritten: dryRun ? [] : [outputPath],
      contentHash,
    };
  }

  /**
   * Escape string for TOML format
   * Handles all special characters per TOML spec
   */
  private escapeTomlString(value: string): string {
    return value
      .replace(/\\/g, "\\\\") // Escape backslash first
      .replace(/"/g, '\\"') // Escape quotes
      .replace(/\n/g, "\\n") // Escape newlines
      .replace(/\r/g, "\\r") // Escape carriage returns
      .replace(/\t/g, "\\t"); // Escape tabs
  }

  private generateTomlContent(unresolvedPlugs?: number): string {
    const lines: string[] = [];

    lines.push("# OpenAI Codex CLI Configuration");
    lines.push("# Generated by AlignTrue");
    lines.push("");
    lines.push("[config]");
    lines.push('version = "v1"');
    lines.push('generated_by = "AlignTrue"');
    if (unresolvedPlugs !== undefined && unresolvedPlugs > 0) {
      lines.push(`unresolved_plugs = ${unresolvedPlugs}`);
    }
    lines.push("");

    this.state.allRules.forEach(({ rule, scopePath }) => {
      lines.push(`[[rules]]`);
      lines.push(`id = "${this.escapeTomlString(rule.id)}"`);
      lines.push(`severity = "${this.escapeTomlString(rule.severity)}"`);
      lines.push(`guidance = "${this.escapeTomlString(rule.guidance || "")}"`);
      lines.push(`scope = "${this.escapeTomlString(scopePath)}"`);
      if (rule.applies_to && rule.applies_to.length > 0) {
        lines.push(
          `applies_to = [${rule.applies_to.map((p) => `"${this.escapeTomlString(p)}"`).join(", ")}]`,
        );
      }
      lines.push("");
    });

    return lines.join("\n");
  }

  resetState(): void {
    this.state = { allRules: [] };
  }
}

export default CodexConfigExporter;
