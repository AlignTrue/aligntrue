/**
 * AGENTS.md parser
 * Parses AGENTS.md universal format back to IR format
 */

import type { AlignRule } from "@aligntrue/schema";

export interface AgentsMdParseResult {
  rules: AlignRule[];
  version: string | undefined;
}

/**
 * Parse AGENTS.md file content to IR format
 * Supports both HTML comment format (with metadata) and legacy section format
 */
export function parseAgentsMd(content: string): AgentsMdParseResult {
  const rules: AlignRule[] = [];

  // Extract version if present
  const versionMatch = content.match(/\*\*Version:\*\*\s+v?(\d+)/i);
  const version = versionMatch ? versionMatch[1] : undefined;

  // Try HTML comment format first (new format with metadata)
  const htmlCommentRules = parseHtmlCommentFormat(content);
  if (htmlCommentRules.length > 0) {
    return { rules: htmlCommentRules, version };
  }

  // Fall back to legacy section format
  const ruleSectionRegex =
    /## Rule: ([^\n]+)\n\n([\s\S]*?)(?=\n## Rule: |\n---\n|\n\*\*Generated by AlignTrue\*\*|$)/g;
  let match;

  // Add iteration limit to prevent infinite loops
  let iterations = 0;
  const maxIterations = 1000;

  while ((match = ruleSectionRegex.exec(content)) !== null) {
    if (++iterations > maxIterations) {
      throw new Error(
        `Parser exceeded maximum iterations (${maxIterations}). This may indicate malformed content.`,
      );
    }

    if (match[1] && match[2]) {
      const ruleName = match[1].trim();
      const ruleBody = match[2].trim();

      const rule = parseAgentsMdRuleSection(ruleName, ruleBody);
      if (rule) {
        rules.push(rule);
      }
    }
  }

  return { rules, version };
}

/**
 * Parse HTML comment format (new format with JSON metadata)
 * Format: <!-- aligntrue:begin {...} --> ... <!-- aligntrue:end {...} -->
 *
 * Uses split-based parsing to avoid ReDoS (Regular Expression Denial of Service)
 * vulnerability. String.split() is linear in input length with no backtracking.
 */
function parseHtmlCommentFormat(content: string): AlignRule[] {
  const rules: AlignRule[] = [];

  // Use string splitting to avoid ReDoS vulnerability with complex regex
  // Split by opening delimiter to find all blocks
  const blocks = content.split(/<!-- aligntrue:begin (\{[^}]*\}) -->/);

  let iterations = 0;
  const maxIterations = 1000;

  // Process blocks (odd indices contain metadata, even indices contain content after)
  for (let i = 1; i < blocks.length; i += 2) {
    if (++iterations > maxIterations) {
      throw new Error(
        `Parser exceeded maximum iterations (${maxIterations}). This may indicate malformed content.`,
      );
    }

    const beginMetadata = blocks[i];
    const contentAfter = blocks[i + 1] || "";

    // Extract the rule content and closing tag
    const endMatch = contentAfter.match(
      /\n## Rule: ([^\n]+)\s*\n([\s\S]*?)<!-- aligntrue:end (\{[^}]*\}) -->/,
    );

    if (!endMatch || !endMatch[1] || !endMatch[2] || !beginMetadata) {
      continue;
    }

    const ruleName = endMatch[1]?.trim();
    const ruleBody = endMatch[2]?.trim();

    if (!ruleName || !ruleBody) {
      continue;
    }

    try {
      // Parse metadata from HTML comment
      const metadata = JSON.parse(beginMetadata) as {
        id?: string;
        applies_to?: string[];
        tags?: string[];
        severity?: string;
      };

      // Parse the rule body for additional fields
      const rule = parseHtmlCommentRuleBody(ruleName, ruleBody, metadata);
      if (rule) {
        rules.push(rule);
      }
    } catch (err) {
      console.warn(
        `Failed to parse HTML comment metadata for rule ${ruleName}:`,
        err,
      );
      continue;
    }
  }

  return rules;
}

/**
 * Parse rule body from HTML comment format
 */
function parseHtmlCommentRuleBody(
  ruleName: string,
  body: string,
  metadata: {
    id?: string;
    applies_to?: string[];
    tags?: string[];
    severity?: string;
  },
): AlignRule | null {
  // Use ID from metadata if available, otherwise use rule name
  const rawId = metadata.id || ruleName;

  // Normalize rule ID
  const { normalized } = normalizeRuleId(rawId);

  // Extract severity from body (required)
  const severityMatch = body.match(/\*\*Severity:\*\*\s+(ERROR|WARN|INFO)/i);
  if (!severityMatch || !severityMatch[1]) {
    console.warn(`AGENTS.md parser: No severity found for rule ${normalized}`);
    return null;
  }
  const severityText = severityMatch[1].toUpperCase();
  const severity = mapSeverity(severityText);

  // Use applies_to from metadata if available, otherwise extract from body
  let applies_to: string[] = metadata.applies_to || [];
  if (applies_to.length === 0) {
    const scopeMatch = body.match(/\*\*Scope:\*\*\s+([^\n]+)/);
    if (scopeMatch && scopeMatch[1]) {
      const patterns = scopeMatch[1].split(",").map((p) => p.trim());
      applies_to.push(...patterns);
    }
  }

  // Extract guidance (everything after metadata lines)
  let guidance = body;
  guidance = guidance.replace(/^\*\*ID:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Severity:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Scope:\*\*.*\n/m, "");
  guidance = guidance.trim();

  // Build rule
  const rule: AlignRule = {
    id: normalized,
    severity,
    applies_to: applies_to.length > 0 ? applies_to : ["**/*"],
    ...(guidance && { guidance }),
    ...(metadata.tags && { tags: metadata.tags }),
  };

  return rule;
}

/**
 * Normalize rule ID to dot notation
 */
function normalizeRuleId(id: string): {
  normalized: string;
  converted: boolean;
} {
  // If already dot notation, return as-is
  if (/^[a-z0-9]+(\.[a-z0-9-]+){2,}$/.test(id)) {
    return { normalized: id, converted: false };
  }

  // Convert kebab-case to dot notation (must have at least 2 hyphens for 3 segments)
  if (/^[a-z0-9]+(-[a-z0-9]+){2,}$/.test(id)) {
    return { normalized: id.replace(/-/g, "."), converted: true };
  }

  // Return as-is if doesn't match either pattern (will fail schema validation)
  return { normalized: id, converted: false };
}

/**
 * Parse individual rule section from AGENTS.md format
 */
function parseAgentsMdRuleSection(
  ruleName: string,
  body: string,
): AlignRule | null {
  // Extract ID (required)
  const idMatch = body.match(/\*\*ID:\*\*\s+([^\n]+)/);
  if (!idMatch) {
    console.warn(
      `AGENTS.md parser: No ID found for rule ${ruleName}, using name as ID`,
    );
  }
  const rawId = idMatch && idMatch[1] ? idMatch[1].trim() : ruleName;

  // Normalize rule ID
  const { normalized, converted } = normalizeRuleId(rawId);
  if (converted) {
    console.log(`  ℹ Converted rule ID: ${rawId} → ${normalized}`);
  }

  // Extract severity (required, mapped from ERROR/WARN/INFO → error/warn/info)
  const severityMatch = body.match(/\*\*Severity:\*\*\s+(ERROR|WARN|INFO)/i);
  if (!severityMatch || !severityMatch[1]) {
    console.warn(`AGENTS.md parser: No severity found for rule ${normalized}`);
    return null;
  }
  const severityText = severityMatch[1].toUpperCase();
  const severity = mapSeverity(severityText);

  // Extract scope/applies_to
  const scopeMatch = body.match(/\*\*Scope:\*\*\s+([^\n]+)/);
  const applies_to: string[] = [];
  if (scopeMatch && scopeMatch[1]) {
    // Parse comma-separated patterns
    const patterns = scopeMatch[1].split(",").map((p) => p.trim());
    applies_to.push(...patterns);
  }

  // Extract guidance (everything after metadata lines)
  let guidance = body;
  // Remove metadata lines
  guidance = guidance.replace(/^\*\*ID:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Severity:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Scope:\*\*.*\n/m, "");
  guidance = guidance.trim();

  // Remove horizontal rules at the end
  guidance = guidance.replace(/^---+$/gm, "").trim();

  // Build rule
  const rule: AlignRule = {
    id: normalized,
    severity,
    applies_to: applies_to.length > 0 ? applies_to : ["**/*"],
    ...(guidance && { guidance }),
  };

  return rule;
}

/**
 * Map AGENTS.md severity format to IR format
 */
function mapSeverity(severityText: string): "error" | "warn" | "info" {
  switch (severityText) {
    case "ERROR":
      return "error";
    case "WARN":
      return "warn";
    case "INFO":
      return "info";
    default:
      console.warn(`Unknown severity: ${severityText}, defaulting to 'info'`);
      return "info";
  }
}
