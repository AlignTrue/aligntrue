/**
 * AGENTS.md parser
 * Parses AGENTS.md universal format back to IR format
 */

import type { AlignRule } from "@aligntrue/schema";

export interface AgentsMdParseResult {
  rules: AlignRule[];
  version: string | undefined;
}

/**
 * Parse AGENTS.md file content to IR format
 */
export function parseAgentsMd(content: string): AgentsMdParseResult {
  const rules: AlignRule[] = [];

  // Extract version if present
  const versionMatch = content.match(/\*\*Version:\*\*\s+v?(\d+)/i);
  const version = versionMatch ? versionMatch[1] : undefined;

  // Extract rule sections (## Rule: <name>)
  const ruleSectionRegex =
    /## Rule: ([^\n]+)\n\n([\s\S]*?)(?=\n## Rule: |\n---\n|\n\*\*Generated by AlignTrue\*\*|$)/g;
  let match;

  while ((match = ruleSectionRegex.exec(content)) !== null) {
    if (match[1] && match[2]) {
      const ruleName = match[1].trim();
      const ruleBody = match[2].trim();

      const rule = parseAgentsMdRuleSection(ruleName, ruleBody);
      if (rule) {
        rules.push(rule);
      }
    }
  }

  return { rules, version };
}

/**
 * Normalize rule ID to dot notation
 */
function normalizeRuleId(id: string): {
  normalized: string;
  converted: boolean;
} {
  // If already dot notation, return as-is
  if (/^[a-z0-9]+(\.[a-z0-9-]+){2,}$/.test(id)) {
    return { normalized: id, converted: false };
  }

  // Convert kebab-case to dot notation (must have at least 2 hyphens for 3 segments)
  if (/^[a-z0-9]+(-[a-z0-9]+){2,}$/.test(id)) {
    return { normalized: id.replace(/-/g, "."), converted: true };
  }

  // Return as-is if doesn't match either pattern (will fail schema validation)
  return { normalized: id, converted: false };
}

/**
 * Parse individual rule section from AGENTS.md format
 */
function parseAgentsMdRuleSection(
  ruleName: string,
  body: string,
): AlignRule | null {
  // Extract ID (required)
  const idMatch = body.match(/\*\*ID:\*\*\s+([^\n]+)/);
  if (!idMatch) {
    console.warn(
      `AGENTS.md parser: No ID found for rule ${ruleName}, using name as ID`,
    );
  }
  const rawId = idMatch && idMatch[1] ? idMatch[1].trim() : ruleName;

  // Normalize rule ID
  const { normalized, converted } = normalizeRuleId(rawId);
  if (converted) {
    console.log(`  ℹ Converted rule ID: ${rawId} → ${normalized}`);
  }

  // Extract severity (required, mapped from ERROR/WARN/INFO → error/warn/info)
  const severityMatch = body.match(/\*\*Severity:\*\*\s+(ERROR|WARN|INFO)/i);
  if (!severityMatch || !severityMatch[1]) {
    console.warn(`AGENTS.md parser: No severity found for rule ${normalized}`);
    return null;
  }
  const severityText = severityMatch[1].toUpperCase();
  const severity = mapSeverity(severityText);

  // Extract scope/applies_to
  const scopeMatch = body.match(/\*\*Scope:\*\*\s+([^\n]+)/);
  const applies_to: string[] = [];
  if (scopeMatch && scopeMatch[1]) {
    // Parse comma-separated patterns
    const patterns = scopeMatch[1].split(",").map((p) => p.trim());
    applies_to.push(...patterns);
  }

  // Extract guidance (everything after metadata lines)
  let guidance = body;
  // Remove metadata lines
  guidance = guidance.replace(/^\*\*ID:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Severity:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Scope:\*\*.*\n/m, "");
  guidance = guidance.trim();

  // Remove horizontal rules at the end
  guidance = guidance.replace(/^---+$/gm, "").trim();

  // Build rule
  const rule: AlignRule = {
    id: normalized,
    severity,
    applies_to: applies_to.length > 0 ? applies_to : ["**/*"],
    ...(guidance && { guidance }),
  };

  return rule;
}

/**
 * Map AGENTS.md severity format to IR format
 */
function mapSeverity(severityText: string): "error" | "warn" | "info" {
  switch (severityText) {
    case "ERROR":
      return "error";
    case "WARN":
      return "warn";
    case "INFO":
      return "info";
    default:
      console.warn(`Unknown severity: ${severityText}, defaulting to 'info'`);
      return "info";
  }
}
