/**
 * AGENTS.md parser
 * Parses AGENTS.md universal format back to IR format
 */

import type { AlignRule } from "@aligntrue/schema";

export interface AgentsMdParseResult {
  rules: AlignRule[];
  version: string | undefined;
}

/**
 * Parse AGENTS.md file content to IR format
 * Supports both HTML comment format (with metadata) and legacy section format
 */
export function parseAgentsMd(content: string): AgentsMdParseResult {
  const rules: AlignRule[] = [];

  // Extract version if present
  const versionMatch = content.match(/\*\*Version:\*\*\s+v?(\d+)/i);
  const version = versionMatch ? versionMatch[1] : undefined;

  // Try HTML comment format first (new format with metadata)
  const htmlCommentRules = parseHtmlCommentFormat(content);
  if (htmlCommentRules.length > 0) {
    return { rules: htmlCommentRules, version };
  }

  // Fall back to legacy section format
  const ruleSectionRegex =
    /## Rule: ([^\n]+)\n\n([\s\S]*?)(?=\n## Rule: |\n---\n|\n\*\*Generated by AlignTrue\*\*|$)/g;
  let match;

  // Add iteration limit to prevent infinite loops
  let iterations = 0;
  const maxIterations = 1000;

  while ((match = ruleSectionRegex.exec(content)) !== null) {
    if (++iterations > maxIterations) {
      throw new Error(
        `Parser exceeded maximum iterations (${maxIterations}). This may indicate malformed content.`,
      );
    }

    if (match[1] && match[2]) {
      const ruleName = match[1].trim();
      const ruleBody = match[2].trim();

      const rule = parseAgentsMdRuleSection(ruleName, ruleBody);
      if (rule) {
        rules.push(rule);
      }
    }
  }

  return { rules, version };
}

/**
 * Parse HTML comment format (new format with JSON metadata)
 * Format: <!-- aligntrue:begin {...} --> ... <!-- aligntrue:end {...} -->
 *
 * Uses iterative string parsing (indexOf) to avoid ReDoS vulnerability.
 * This is safer than complex regex with nested quantifiers.
 */
function parseHtmlCommentFormat(content: string): AlignRule[] {
  const rules: AlignRule[] = [];

  let pos = 0;
  let iterations = 0;
  const maxIterations = 1000;
  const beginDelim = "<!-- aligntrue:begin ";
  const beginEnd = " -->";
  const ruleHeader = "\n## Rule: ";
  const endDelim = "<!-- aligntrue:end ";

  while (true) {
    if (++iterations > maxIterations) {
      throw new Error(
        `Parser exceeded maximum iterations (${maxIterations}). This may indicate malformed content.`,
      );
    }

    // Find opening tag
    const beginIdx = content.indexOf(beginDelim, pos);
    if (beginIdx === -1) break;

    // Find end of opening tag (get metadata)
    const metaStart = beginIdx + beginDelim.length;
    const metaEnd = content.indexOf(beginEnd, metaStart);
    if (metaEnd === -1) break;

    const beginMetadata = content.substring(metaStart, metaEnd);
    pos = metaEnd + beginEnd.length;

    // Find rule header
    const ruleHeaderIdx = content.indexOf(ruleHeader, pos);
    if (ruleHeaderIdx === -1) break;

    const ruleNameStart = ruleHeaderIdx + ruleHeader.length;
    const ruleNameEnd = content.indexOf("\n", ruleNameStart);
    if (ruleNameEnd === -1) break;

    const ruleName = content.substring(ruleNameStart, ruleNameEnd).trim();

    // Find end tag - scan from current position
    const endDelimIdx = content.indexOf(endDelim, ruleNameEnd);
    if (endDelimIdx === -1) break;

    // Extract body between rule header line and end tag
    const bodyStart = ruleNameEnd + 1;
    const ruleBody = content.substring(bodyStart, endDelimIdx).trim();

    if (!ruleName || !ruleBody) {
      pos = endDelimIdx + 1;
      continue;
    }

    try {
      // Parse metadata from HTML comment
      const metadata = JSON.parse(beginMetadata) as {
        id?: string;
        applies_to?: string[];
        tags?: string[];
        severity?: string;
      };

      // Parse the rule body for additional fields
      const rule = parseHtmlCommentRuleBody(ruleName, ruleBody, metadata);
      if (rule) {
        rules.push(rule);
      }
    } catch (err) {
      console.warn(
        `Failed to parse HTML comment metadata for rule ${ruleName}:`,
        err,
      );
    }

    // Move position past the end tag
    const endTagEnd = content.indexOf(" -->", endDelimIdx);
    pos = endTagEnd !== -1 ? endTagEnd + 4 : endDelimIdx + endDelim.length;
  }

  return rules;
}

/**
 * Parse rule body from HTML comment format
 */
function parseHtmlCommentRuleBody(
  ruleName: string,
  body: string,
  metadata: {
    id?: string;
    applies_to?: string[];
    tags?: string[];
    severity?: string;
  },
): AlignRule | null {
  // Use ID from metadata if available, otherwise use rule name
  const rawId = metadata.id || ruleName;

  // Normalize rule ID
  const { normalized } = normalizeRuleId(rawId);

  // Extract severity from body (required)
  const severityMatch = body.match(/\*\*Severity:\*\*\s+(ERROR|WARN|INFO)/i);
  if (!severityMatch || !severityMatch[1]) {
    console.warn(`AGENTS.md parser: No severity found for rule ${normalized}`);
    return null;
  }
  const severityText = severityMatch[1].toUpperCase();
  const severity = mapSeverity(severityText);

  // Use applies_to from metadata if available, otherwise extract from body
  let applies_to: string[] = metadata.applies_to || [];
  if (applies_to.length === 0) {
    const scopeMatch = body.match(/\*\*Scope:\*\*\s+([^\n]+)/);
    if (scopeMatch && scopeMatch[1]) {
      const patterns = scopeMatch[1].split(",").map((p) => p.trim());
      applies_to.push(...patterns);
    }
  }

  // Extract guidance (everything after metadata lines)
  let guidance = body;
  guidance = guidance.replace(/^\*\*ID:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Severity:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Scope:\*\*.*\n/m, "");
  guidance = guidance.trim();

  // Build rule
  const rule: AlignRule = {
    id: normalized,
    severity,
    applies_to: applies_to.length > 0 ? applies_to : ["**/*"],
    ...(guidance && { guidance }),
    ...(metadata.tags && { tags: metadata.tags }),
  };

  return rule;
}

/**
 * Normalize rule ID to dot notation
 */
function normalizeRuleId(id: string): {
  normalized: string;
  converted: boolean;
} {
  // If already dot notation, return as-is
  if (/^[a-z0-9]+(\.[a-z0-9-]+){2,}$/.test(id)) {
    return { normalized: id, converted: false };
  }

  // Convert kebab-case to dot notation (must have at least 2 hyphens for 3 segments)
  if (/^[a-z0-9]+(-[a-z0-9]+){2,}$/.test(id)) {
    return { normalized: id.replace(/-/g, "."), converted: true };
  }

  // Return as-is if doesn't match either pattern (will fail schema validation)
  return { normalized: id, converted: false };
}

/**
 * Parse individual rule section from AGENTS.md format
 */
function parseAgentsMdRuleSection(
  ruleName: string,
  body: string,
): AlignRule | null {
  // Extract ID (required)
  const idMatch = body.match(/\*\*ID:\*\*\s+([^\n]+)/);
  if (!idMatch) {
    console.warn(
      `AGENTS.md parser: No ID found for rule ${ruleName}, using name as ID`,
    );
  }
  const rawId = idMatch && idMatch[1] ? idMatch[1].trim() : ruleName;

  // Normalize rule ID
  const { normalized, converted } = normalizeRuleId(rawId);
  if (converted) {
    console.log(`  ℹ Converted rule ID: ${rawId} → ${normalized}`);
  }

  // Extract severity (required, mapped from ERROR/WARN/INFO → error/warn/info)
  const severityMatch = body.match(/\*\*Severity:\*\*\s+(ERROR|WARN|INFO)/i);
  if (!severityMatch || !severityMatch[1]) {
    console.warn(`AGENTS.md parser: No severity found for rule ${normalized}`);
    return null;
  }
  const severityText = severityMatch[1].toUpperCase();
  const severity = mapSeverity(severityText);

  // Extract scope/applies_to
  const scopeMatch = body.match(/\*\*Scope:\*\*\s+([^\n]+)/);
  const applies_to: string[] = [];
  if (scopeMatch && scopeMatch[1]) {
    // Parse comma-separated patterns
    const patterns = scopeMatch[1].split(",").map((p) => p.trim());
    applies_to.push(...patterns);
  }

  // Extract guidance (everything after metadata lines)
  let guidance = body;
  // Remove metadata lines
  guidance = guidance.replace(/^\*\*ID:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Severity:\*\*.*\n/m, "");
  guidance = guidance.replace(/^\*\*Scope:\*\*.*\n/m, "");
  guidance = guidance.trim();

  // Remove horizontal rules at the end
  guidance = guidance.replace(/^---+$/gm, "").trim();

  // Build rule
  const rule: AlignRule = {
    id: normalized,
    severity,
    applies_to: applies_to.length > 0 ? applies_to : ["**/*"],
    ...(guidance && { guidance }),
  };

  return rule;
}

/**
 * Map AGENTS.md severity format to IR format
 */
function mapSeverity(severityText: string): "error" | "warn" | "info" {
  switch (severityText) {
    case "ERROR":
      return "error";
    case "WARN":
      return "warn";
    case "INFO":
      return "info";
    default:
      console.warn(`Unknown severity: ${severityText}, defaulting to 'info'`);
      return "info";
  }
}
