/**
 * Tests for Cursor .mdc parser
 */

import { describe, it, expect } from 'vitest'
import { parseCursorMdc, parseCursorMdcFiles } from '../../src/parsers/cursor.js'

describe('parseCursorMdc', () => {
  it('should parse basic rule', () => {
    const content = `---
description: Test rules
alwaysApply: true
---
## Rule: test-rule

**Severity:** error

**Applies to:**
- \`**/*.ts\`
- \`**/*.tsx\`

This is the guidance text.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0]).toMatchObject({
      id: 'test-rule',
      severity: 'error',
      applies_to: ['**/*.ts', '**/*.tsx'],
      guidance: 'This is the guidance text.',
    })
  })

  it('should parse rule without applies_to (defaults to **/*)', () => {
    const content = `---
description: Test rules
---
## Rule: no-applies-to

**Severity:** warn

Guidance without applies_to section.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].applies_to).toEqual(['**/*'])
  })

  it('should parse multiple rules', () => {
    const content = `---
description: Test rules
---
## Rule: rule-one

**Severity:** error

**Applies to:**
- \`*.ts\`

First rule guidance.

## Rule: rule-two

**Severity:** warn

**Applies to:**
- \`*.js\`

Second rule guidance.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    expect(rules[0].id).toBe('rule-one')
    expect(rules[1].id).toBe('rule-two')
  })

  it('should extract vendor.cursor metadata from frontmatter', () => {
    const content = `---
description: Test rules
cursor:
  test-rule:
    ai_hint: "Suggest fixes"
    quick_fix: true
---
## Rule: test-rule

**Severity:** error

Guidance text.
`

    const { rules, vendorMetadata } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].vendor).toEqual({
      cursor: {
        ai_hint: 'Suggest fixes',
        quick_fix: true,
      }
    })
    expect(vendorMetadata['test-rule']).toEqual({
      ai_hint: 'Suggest fixes',
      quick_fix: true,
    })
  })

  it('should handle multiline guidance', () => {
    const content = `---
description: Test rules
---
## Rule: multiline-rule

**Severity:** info

**Applies to:**
- \`**/*.md\`

This is line one.
This is line two.

This is a new paragraph.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules[0].guidance).toContain('line one')
    expect(rules[0].guidance).toContain('line two')
    expect(rules[0].guidance).toContain('new paragraph')
  })

  it('should handle rule with footer (stops parsing at ---)', () => {
    const content = `---
description: Test rules
---
## Rule: test-rule

**Severity:** error

Guidance text.

---

**Generated by AlignTrue**
Content Hash: abc123
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].guidance).not.toContain('Generated by')
  })

  it('should handle missing severity gracefully', () => {
    const content = `---
description: Test rules
---
## Rule: no-severity

**Applies to:**
- \`*.ts\`

Guidance text.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(0)  // Should skip invalid rule
  })

  it('should normalize severity case', () => {
    const content = `---
description: Test rules
---
## Rule: upper-case

**Severity:** ERROR

Test.

## Rule: mixed-case

**Severity:** Warn

Test.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    expect(rules[0].severity).toBe('error')
    expect(rules[1].severity).toBe('warn')
  })

  it('should parse real golden repo format', () => {
    const content = `---
description: AlignTrue rules (default scope)
alwaysApply: true
cursor:
  typescript-no-any:
    ai_hint: "Suggest specific types based on usage context"
    quick_fix: true
---
## Rule: testing-require-tests

**Severity:** error

**Applies to:**
- \`src/**/*.ts\`
- \`src/**/*.tsx\`

Every new feature must include unit tests. Test files should be co-located
with source files using the .test.ts or .spec.ts naming convention.

Examples:
- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx

## Rule: typescript-no-any

**Severity:** warn

**Applies to:**
- \`**/*.ts\`
- \`**/*.tsx\`

Avoid using 'any' type as it defeats TypeScript's type safety.
Use 'unknown' for truly unknown types, or define proper interfaces.

---

**Generated by AlignTrue**
Content Hash: abc123
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    
    expect(rules[0]).toMatchObject({
      id: 'testing.require.tests',
      severity: 'error',
      applies_to: ['src/**/*.ts', 'src/**/*.tsx'],
    })
    expect(rules[0].guidance).toContain('unit tests')
    
    expect(rules[1]).toMatchObject({
      id: 'typescript.no.any',
      severity: 'warn',
      applies_to: ['**/*.ts', '**/*.tsx'],
      mode: 'always',
      description: 'AlignTrue rules (default scope)',
    })
    expect(rules[1].vendor).toEqual({
      cursor: {
        ai_hint: 'Suggest specific types based on usage context',
        quick_fix: true,
      }
    })
  })
})

describe('parseCursorMdcFiles', () => {
  it('should merge rules from multiple files', () => {
    const files = new Map([
      ['file1.mdc', `---
---
## Rule: testing.example.one

**Severity:** error

Guidance one.
`],
      ['file2.mdc', `---
---
## Rule: testing.example.two

**Severity:** warn

Guidance two.
`],
    ])

    const rules = parseCursorMdcFiles(files)
    
    expect(rules).toHaveLength(2)
    expect(rules.map(r => r.id)).toEqual(['testing.example.one', 'testing.example.two'])
  })

  it('should deduplicate rules by ID (last wins)', () => {
    const files = new Map([
      ['file1.mdc', `---
---
## Rule: shared-rule

**Severity:** error

First version.
`],
      ['file2.mdc', `---
---
## Rule: shared-rule

**Severity:** warn

Second version.
`],
    ])

    const rules = parseCursorMdcFiles(files)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].severity).toBe('warn')
    expect(rules[0].guidance).toBe('Second version.')
  })
})

describe('Cursor mode preservation', () => {
  it('should map alwaysApply to mode: "always"', () => {
    const content = `---
description: Test rules
alwaysApply: true
---
## Rule: test.rule.id

**Severity:** error

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].mode).toBe('always')
  })

  it('should map intelligent to mode: "intelligent" with description', () => {
    const content = `---
intelligent: true
description: "Smart rules"
---
## Rule: test.rule.id

**Severity:** warn

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].mode).toBe('intelligent')
    expect(rules[0].description).toBe('Smart rules')
  })

  it('should map globs to mode: "files" and applies_to', () => {
    const content = `---
globs:
  - "src/**/*.ts"
  - "tests/**/*.test.ts"
---
## Rule: test.rule.id

**Severity:** info

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].mode).toBe('files')
    expect(rules[0].applies_to).toEqual([
      'src/**/*.ts',
      'tests/**/*.test.ts'
    ])
  })

  it('should store file-level metadata in ALL rules', () => {
    const content = `---
alwaysApply: true
description: "Shared metadata"
---
## Rule: first.rule.id

**Severity:** error

First rule.

## Rule: second.rule.id

**Severity:** warn

Second rule.
`
    const { rules } = parseCursorMdc(content)
    expect(rules).toHaveLength(2)
    expect(rules[0].mode).toBe('always')
    expect(rules[0].description).toBe('Shared metadata')
    expect(rules[1].mode).toBe('always')
    expect(rules[1].description).toBe('Shared metadata')
  })

  it('should pass-through unknown frontmatter fields to vendor.cursor._unknown', () => {
    const content = `---
alwaysApply: true
customField: "custom value"
futureFeature: 42
---
## Rule: test.rule.id

**Severity:** error

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].vendor?.cursor?._unknown?.customField).toBe('custom value')
    expect(rules[0].vendor?.cursor?._unknown?.futureFeature).toBe(42)
  })

  it('should merge file-level schema fields and per-rule vendor metadata', () => {
    const content = `---
alwaysApply: true
description: "File-level desc"
cursor:
  test.rule.id:
    ai_hint: "Per-rule hint"
    quick_fix: true
---
## Rule: test.rule.id

**Severity:** error

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].mode).toBe('always')
    expect(rules[0].description).toBe('File-level desc')
    expect(rules[0].vendor?.cursor).toEqual({
      ai_hint: 'Per-rule hint',
      quick_fix: true,
    })
  })

  it('should handle intelligent mode priority over alwaysApply', () => {
    const content = `---
description: "Production rules"
alwaysApply: false
intelligent: true
---
## Rule: test.rule.id

**Severity:** warn

Test guidance.
`
    const { rules } = parseCursorMdc(content)
    // Intelligent takes priority over alwaysApply in mode detection
    expect(rules[0].mode).toBe('intelligent')
    expect(rules[0].description).toBe('Production rules')
  })

  it('should default to mode: "manual" when no mode specified', () => {
    const content = `---
description: "Manual rules"
---
## Rule: test.rule.id

**Severity:** warn

Test.
`
    const { rules } = parseCursorMdc(content)
    expect(rules[0].mode).toBe('manual')
    expect(rules[0].description).toBe('Manual rules')
  })
})

