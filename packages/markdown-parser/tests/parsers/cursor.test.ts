/**
 * Tests for Cursor .mdc parser
 */

import { describe, it, expect } from 'vitest'
import { parseCursorMdc, parseCursorMdcFiles } from '../../src/parsers/cursor.js'

describe('parseCursorMdc', () => {
  it('should parse basic rule', () => {
    const content = `---
description: Test rules
alwaysApply: true
---
## Rule: test-rule

**Severity:** error

**Applies to:**
- \`**/*.ts\`
- \`**/*.tsx\`

This is the guidance text.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0]).toMatchObject({
      id: 'test-rule',
      severity: 'error',
      applies_to: ['**/*.ts', '**/*.tsx'],
      guidance: 'This is the guidance text.',
    })
  })

  it('should parse rule without applies_to (defaults to **/*)', () => {
    const content = `---
description: Test rules
---
## Rule: no-applies-to

**Severity:** warn

Guidance without applies_to section.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].applies_to).toEqual(['**/*'])
  })

  it('should parse multiple rules', () => {
    const content = `---
description: Test rules
---
## Rule: rule-one

**Severity:** error

**Applies to:**
- \`*.ts\`

First rule guidance.

## Rule: rule-two

**Severity:** warn

**Applies to:**
- \`*.js\`

Second rule guidance.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    expect(rules[0].id).toBe('rule-one')
    expect(rules[1].id).toBe('rule-two')
  })

  it('should extract vendor.cursor metadata from frontmatter', () => {
    const content = `---
description: Test rules
cursor:
  test-rule:
    ai_hint: "Suggest fixes"
    quick_fix: true
---
## Rule: test-rule

**Severity:** error

Guidance text.
`

    const { rules, vendorMetadata } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].vendor).toEqual({
      cursor: {
        ai_hint: 'Suggest fixes',
        quick_fix: true,
      }
    })
    expect(vendorMetadata['test-rule']).toEqual({
      ai_hint: 'Suggest fixes',
      quick_fix: true,
    })
  })

  it('should handle multiline guidance', () => {
    const content = `---
description: Test rules
---
## Rule: multiline-rule

**Severity:** info

**Applies to:**
- \`**/*.md\`

This is line one.
This is line two.

This is a new paragraph.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules[0].guidance).toContain('line one')
    expect(rules[0].guidance).toContain('line two')
    expect(rules[0].guidance).toContain('new paragraph')
  })

  it('should handle rule with footer (stops parsing at ---)', () => {
    const content = `---
description: Test rules
---
## Rule: test-rule

**Severity:** error

Guidance text.

---

**Generated by AlignTrue**
Content Hash: abc123
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].guidance).not.toContain('Generated by')
  })

  it('should handle missing severity gracefully', () => {
    const content = `---
description: Test rules
---
## Rule: no-severity

**Applies to:**
- \`*.ts\`

Guidance text.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(0)  // Should skip invalid rule
  })

  it('should normalize severity case', () => {
    const content = `---
description: Test rules
---
## Rule: upper-case

**Severity:** ERROR

Test.

## Rule: mixed-case

**Severity:** Warn

Test.
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    expect(rules[0].severity).toBe('error')
    expect(rules[1].severity).toBe('warn')
  })

  it('should parse real golden repo format', () => {
    const content = `---
description: AlignTrue rules (default scope)
alwaysApply: true
cursor:
  typescript-no-any:
    ai_hint: "Suggest specific types based on usage context"
    quick_fix: true
---
## Rule: testing-require-tests

**Severity:** error

**Applies to:**
- \`src/**/*.ts\`
- \`src/**/*.tsx\`

Every new feature must include unit tests. Test files should be co-located
with source files using the .test.ts or .spec.ts naming convention.

Examples:
- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx

## Rule: typescript-no-any

**Severity:** warn

**Applies to:**
- \`**/*.ts\`
- \`**/*.tsx\`

Avoid using 'any' type as it defeats TypeScript's type safety.
Use 'unknown' for truly unknown types, or define proper interfaces.

---

**Generated by AlignTrue**
Content Hash: abc123
`

    const { rules } = parseCursorMdc(content)
    
    expect(rules).toHaveLength(2)
    
    expect(rules[0]).toMatchObject({
      id: 'testing.require.tests',
      severity: 'error',
      applies_to: ['src/**/*.ts', 'src/**/*.tsx'],
    })
    expect(rules[0].guidance).toContain('unit tests')
    
    expect(rules[1]).toMatchObject({
      id: 'typescript.no.any',
      severity: 'warn',
      applies_to: ['**/*.ts', '**/*.tsx'],
    })
    expect(rules[1].vendor).toEqual({
      cursor: {
        ai_hint: 'Suggest specific types based on usage context',
        quick_fix: true,
      }
    })
  })
})

describe('parseCursorMdcFiles', () => {
  it('should merge rules from multiple files', () => {
    const files = new Map([
      ['file1.mdc', `---
---
## Rule: testing.example.one

**Severity:** error

Guidance one.
`],
      ['file2.mdc', `---
---
## Rule: testing.example.two

**Severity:** warn

Guidance two.
`],
    ])

    const rules = parseCursorMdcFiles(files)
    
    expect(rules).toHaveLength(2)
    expect(rules.map(r => r.id)).toEqual(['testing.example.one', 'testing.example.two'])
  })

  it('should deduplicate rules by ID (last wins)', () => {
    const files = new Map([
      ['file1.mdc', `---
---
## Rule: shared-rule

**Severity:** error

First version.
`],
      ['file2.mdc', `---
---
## Rule: shared-rule

**Severity:** warn

Second version.
`],
    ])

    const rules = parseCursorMdcFiles(files)
    
    expect(rules).toHaveLength(1)
    expect(rules[0].severity).toBe('warn')
    expect(rules[0].guidance).toBe('Second version.')
  })
})

