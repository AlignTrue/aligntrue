# Extracted Rules

## Extracted from: .cursor/rules/vision_strategy_roadmap.mdc

---

## description: AlignTrue vision and strategy roadmap

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# AlignTrue — Vision and Strategy Roadmap

**Last updated:** Nov 30, 2025

---

## Vision

AlignTrue is the alignment control plane. One shared, versioned rule layer that keeps AI agents, developers, product managers, and leadership operating from the same priorities. Drift becomes a signal that improves the rules. The system meets people where they work and quietly keeps everything in sync.

**One line:** Source of truth for how you want work done, wired into every agent and workflow.

---

## North Star and 60-Second Wow

**Promise**

Align rules across agents in 60 seconds & your team in 5 minutes.

**Quick demo**

```bash
npx aligntrue init    # Auto-detects agents, creates AGENTS.md
aligntrue sync        # Exports to all detected agents
```

**Result**

- Rules synced to all your agents (Cursor, Copilot, Claude, VS Code MCP, etc.)
- Edit AGENTS.md or any agent file; sync keeps them in sync
- Team mode available: lockfiles, drift detection, CI validation

---

## Positioning

- **Category:** AI and org alignment control plane
- **Starting wedge:** OSS CLI that syncs rules across agents and repos
- **Core mechanic:** Scopes and storage policies on rules, plus unidirectional sync
- **Signature move:** Treat drift as a signal, not a crime
- **Promise:** Clarity in a week, compounding alignment over time

---

## First Principles

1. Clarity beats clever. Rules must be explicit, testable, and versioned.
2. Determinism by default. Canonicalization and hashing to remove ambiguity.
3. Unidirectional sync keeps truth in one place. Edit in `.aligntrue/rules/`, sync flows to all agents.
4. Drift is data. Use it to update rules or fix behavior.
5. Meet people where they work. IDEs, Linear, Slack, Docs, not a new inbox.
6. Privacy first. Scopes and storage policies prevent leaks.

---

## Product Thesis

AI only helps when guidance is clear. Writing rules forces priorities and tradeoffs to be explicit. That clarity aligns humans and agents and removes most friction. Start with developers because they feel the pain today. Use that wedge to bring PMs, then leadership, then the whole org.

---

## Technical Invariants

- **IR spec:** YAML with sections[] that each have heading, body, scope in {team, personal}, storage in {local, repo, remote:<name>, cloud}, id.
- **Canonical form:** JCS style JSON plus SHA-256 of normalized content for stable IDs.
- **Scope wins over heuristics:** Once a section has a scope, it cannot be auto re scoped by headings.
- **Sync rules:** IR is complete. Exports filter by scope and storage. Lockfile contains team scope only.
- **Safety:** In team mode, no personal with storage repo in shared repos.
- **Status checks:** aligntrue status and aligntrue doctor show where rules live and if anything leaks.

---

## Roadmap Overview

| Phase | Name              | Goal                                       | Key Outputs                                                                                               | Gate Metrics                                                               |
| ----- | ----------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| 0     | OSS Default       | Become the obvious CLI for agent rule sync | IR v1, scope and storage, unidirectional sync, 25+ exporters, detectors, lockfile, status, doctor, aligns | 5k GitHub stars, 1k weekly active repos, 50% success rate on status checks |
| 1     | Teams             | Multiplayer and governance                 | Team mode, policy inheritance, allow list, CI checks, PR annotations, audit log                           | 200 paying teams, NRR 120, CI adoption 70 percent of repos using checks    |
| 2     | PM Bridge         | Turn PM vision into dev reality            | Linear and Jira integration, rule to backlog mapping, priority guardrails, PRD and doc checks             | 1k PM weekly users, 30 percent of merged PRs linked to rules               |
| 3     | Org Control Plane | Central source of truth in cloud           | Workspaces, SSO, SCIM, data residency, drift dashboard, Slack and Docs add ons, scheduled scans           | 200 enterprise trials, 50 enterprise wins, NRR 130                         |
| 4     | Platform          | Make it a standard                         | Rule align marketplace, compliance aligns, hiring signal, analytics API                                   | 10k orgs using aligns, 20 percent revenue from add ons                     |
| 5     | Civic Pilot       | Prove it beyond companies                  | Public rule spaces, candidate rule sets, citizen feedback flows                                           | 3 pilots with credible NGOs or municipalities                              |

---

## Phase 0 — OSS Default

**Objective:** Become the default way developers sync rules across agents.

### Milestones

- IR v1 with scope and storage
- Unidirectional sync to AGENTS.md, CLAUDE.md, .mdc
- Lockfile and allow list with team scope only
- status, doctor, diff, check --sarif
- 50+ exporters and detectors with golden tests
- Aligns for common stacks

### 80/20 Focus

- Nail stability of unidirectional sync and section IDs
- Status and doctor UX that explains exactly what will happen before it happens
- Exporter coverage for Cursor, Claude, Gemini, VS Code, AGENTS.md, MCP configs

### Risks

- Perceived as a thin sync tool
- Exporters flaky

### Mitigation

- Deterministic tests, snapshots, and public CI
- Clear spec docs, short recipes, and quick wins

---

## Phase 1 — Teams

**Objective:** Multiplayer alignment in repos and CI.

### Milestones

- Team mode with policy inheritance and exceptions
- CI checks with PR comments and required status
- Audit log, provenance, and signed lockfiles
- aligntrue approve workflow with CODEOWNERS

### 80/20 Focus

- CI checks that catch real drift and produce helpful fixes
- Simple inheritance model that people grasp in one read

### Risks

- Change management friction

### Mitigation

- Zero config path, clear diff output, short video demos

---

## Phase 2 — PM Bridge

**Objective:** Let PMs encode vision, priorities, and tradeoffs that drive the backlog.

### Milestones

- Linear and Jira connectors
- Rules to backlog mapping and guardrails
- Doc and PRD checkers
- Drift signals sent to PMs when teams diverge or when rules go stale

### 80/20 Focus

- One view where a PM can see priorities and active work linked to rules
- A single killer guardrail that prevents common misalignment

### Risks

- PMs see it as yet another tool

### Mitigation

- Live inside Linear and Jira, not next to them

---

## Phase 3 — Org Control Plane

**Objective:** Cloud source of truth and cross tool checks.

### Milestones

- Workspaces, SSO, SCIM
- Data residency and customer keys
- Slack slash commands and listeners
- Google Docs and Office add ons
- Drift dashboard and rule health scores

### 80/20 Focus

- Slack and Docs checks that feel like magic and do not nag
- Drift insights that explain the why, not just the what

### Risks

- Overreach on scanning and privacy concerns

### Mitigation

- Opt in scopes, transparent logs, privacy by design

---

## Phase 4 — Platform

**Objective:** Become the standard alignment layer.

### Milestones

- Align marketplace and verified aligns
- Compliance and industry aligns
- Hiring signal and public rule profiles
- Analytics API and partner ecosystem

### 80/20 Focus

- High quality official aligns that save months of work
- Two or three anchor partnerships

---

## Phase 5 — Civic Pilot

**Objective:** Validate the model in public interest settings.

### Milestones

- Candidate and policy rule sets
- Drift feedback from citizens
- Moderation and transparency features

### Guardrails

- Non partisan posture and strict transparency

---

## Go To Market

- **Bottom up:** OSS first, templates, quick wins, community
- **Product led:** Free to try, checks that prove value in a week
- **Lightweight sales:** Land teams through CI checks, expand to PMs and org
- **Enterprise:** Control plane features, security reviews, data residency

### Pricing Spine

| Tier     | For         | Price                                  | Key Value                           |
| -------- | ----------- | -------------------------------------- | ----------------------------------- |
| Free OSS | Individuals | Free                                   | Rule sync and core exporters        |
| Pro      | Teams       | 6 to 12 per user per month             | CI checks, team mode, inheritance   |
| Platform | Orgs        | 150 to 300 per user per year plus base | SSO, SCIM, drift dashboard, add ons |

---

## Metrics That Matter

- Weekly active rule checks per repo or seat
- Percent of PRs linked to rules
- Drift resolved within target days
- PM adoption and depth across teams
- NRR and team to org expansion rate

---

## Brutal Analysis

### Strengths

- Starts with a painful, concrete dev problem and ships a fast win
- Clear path from local rules to org alignment without changing story
- Drift as signal is a unique, compounding insight

### Weak Spots

- Incumbents can bolt on rule sync to their surfaces
- Change management is hard if value is not obvious in week one
- Risk of being seen as policy or OKR tooling

### How to De-Risk

- Be the best in class at unidirectional sync and exporter coverage
- Make CI checks and Slack checks obviously useful on day one
- Speak in outcomes, not governance. Ship recipes that save time

---

## 80/20 per Phase

- **Phase 0:** Unidirectional sync that never loses a section. Best in class status and doctor. Exporter coverage for the top agents and IDEs.
- **Phase 1:** CI checks that prevent real mistakes and are easy to approve. Inheritance that is simple and predictable.
- **Phase 2:** Linear and Jira flows that help PMs steer a sprint with one view and one guardrail. No new inbox.
- **Phase 3:** Slack and Docs checks that feel native. Drift dashboard that shows why and what to change.
- **Phase 4:** A small set of official rule aligns that set the standard. A few deep partners.
- **Phase 5:** One credible civic pilot with clear transparency.

---

## Validation Plan and Kill Switches

- **Phase 0 gates:** If unidirectional sync stability or exporter quality stays below target after three iterations, cut long tail exporters and refocus on top five.
- **Phase 1 gates:** If CI checks do not drive adoption, simplify checks and raise signal quality before adding features.
- **Phase 2 gates:** If PM attach is weak, add one killer guardrail that saves a sprint. Do not build dashboards until attach is real.
- **Phase 3 gates:** If privacy pushback rises, pivot to on prem and private indexing for checks.

---

## Naming and Messaging Options

- Alignment control plane
- Rules backbone for AI and orgs
- Source of truth for how you want work done

---

## What Would Change My Mind

- If incumbents ship true unidirectional sync across agents and tools and win usage fast
- If PM attach does not materialize after strong integrations
- If teams resist writing rules even with clear wins

---

## Immediate Next Steps

1. Lock IR v1 with scope and storage
2. Finish unidirectional sync with stable IDs and conflict rules
3. Ship status, doctor, and CI check with helpful diffs
4. Add Linear integration with one guardrail and one view
5. Publish three high quality aligns with tests

## Extracted from: .cursor/rules/typescript.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# TypeScript Type Safety

Avoid using 'any' type as it defeats TypeScript's type safety. Use 'unknown' for truly unknown types, or define proper interfaces.

## Extracted from: .cursor/rules/testing.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Testing Standards

Add or update tests for any nontrivial change. Use the existing test framework and patterns in this project.

## Test Quality

- Prefer fast, focused unit tests.
- Only use integration or end-to-end tests when necessary.
- Test behavior, not implementation details.
- Keep tests independent and deterministic.
- Use descriptive test names that explain what is being tested.

## Test Design

- Tests should act as executable specs: clear names, simple setups, deterministic assertions.
- Explain why a test is missing if you cannot add one, and call out the risk.
- When fixing a bug, add a regression test that fails before the fix and passes after.
- Aim for test coverage that gives confidence in correctness (target 80%+ for critical code).

## Test Co-location

Place test files next to source files using the `.test.*` or `.spec.*` naming convention:

- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx

## Extracted from: .cursor/rules/test_log_template.mdc

---

## description: Use this template for documenting test runs.

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Test Run Template

Use this template for documenting test runs.

## Test Run {YYYY-MM-DD HH:MM}

**Environment:**

- Commit: {git commit hash}
- Node: {node --version}
- Platform: {darwin|linux|win32}
- Test Type: {local|ci|manual}

**Test Execution:**

- Code Source: {local workspace|remote commit}
- Environment: {hermetic|workspace}
- Test Directory: {path to test dir}

---

## Findings

### Confirmed Bugs

#### [P0] {Bug Title}

**Description:** {What's broken}

**Root cause:** {Why it's broken}

**Reproduction:**

```bash
# Steps to reproduce
```

**Fix:** {How to fix it}

**Files affected:**

- `{file path}`
- `{file path}`

---

#### [P1] {Bug Title}

{Same structure as P0}

---

### Test Execution Issues

#### {Issue Title}

**What went wrong:** {Description of test setup/execution problem}

**Impact:** {Did this invalidate test results?}

**How to fix:** {For next test run}

---

### Coverage Gaps

#### {Gap Title}

**What wasn't tested:** {Description}

**Why:** {Reason - time, complexity, dependencies, etc.}

**Plan:** {When/how to test this}

---

## Summary

**Bugs found:** {count} ({P0 count} P0, {P1 count} P1, {P2 count} P2)

**Tests passed:** {count}/{total}

**Coverage:** {percentage or description}

**Release readiness:** {Ready|Blocked|Needs work}

**Blockers:**

- {List any P0 bugs blocking release}

**Next steps:**

1. {Action item}
2. {Action item}
3. {Action item}

## Extracted from: .cursor/rules/security_linting_policy.mdc

---

description: Security linting policy for scripts and packages
globs:

- scripts/\*_/_.js
- scripts/\*_/_.mjs
- packages/\*_/_.ts
- packages/\*_/_.tsx
- apps/\*_/_.ts
- apps/\*_/_.tsx

---

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Security Linting Policy

**Applies to**: `scripts/**/*.{js,mjs}`, `packages/**/*.{ts,tsx}`, `apps/**/*.{ts,tsx}`

## Overview

This document defines when to suppress vs fix security warnings from `eslint-plugin-security` to ensure `pnpm check` only shows actionable warnings. It covers both TypeScript source files and JavaScript tooling scripts like build tools, validation scripts, and CLI utilities.

## Core Principle

**Suppress false positives with documentation. Fix real vulnerabilities.**

## When to Suppress

### 1. Safe Internal Paths

**Suppress**: `security/detect-non-literal-fs-filename` for:

- Schema files resolved from `__dirname` at build time
- Paths from `getAlignTruePaths()` helper (all are safe internal paths)
- Lockfile, bundle, and IR file paths (`.aligntrue/rules`, `.aligntrue/lock.json`, etc.)
- Test fixtures and temporary files

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Internal schema file path, resolved from __dirname at build time (not user input)
const configSchema = JSON.parse(readFileSync(schemaPath, "utf8"));
```

**Rationale**: These paths are not user-controlled and are safe by construction.

### 2. Validated User Input

**Suppress**: `security/detect-non-literal-fs-filename` for paths that:

- Go through `validateScopePath()` at config load time
- Are validated for path traversal attacks
- Are checked for absolute paths

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Paths from config are validated via validateScopePath() at config load time (packages/core/src/config/index.ts:662)
content = readFileSync(sourcePath, "utf8");
```

**Rationale**: Validation prevents path traversal attacks, making the path safe.

### 3. Prototype Pollution Protection

**Suppress**: `security/detect-object-injection` for dynamic property access that:

- Has explicit `__proto__`, `constructor`, `prototype` checks before access
- Uses `Object.prototype.hasOwnProperty.call()` for property checks
- Validates keys before accessing object properties

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-object-injection
// Safe: Prototype pollution prevented by explicit __proto__/constructor/prototype checks above (lines 38-46)
current[segment] = {};
```

**Rationale**: Explicit checks prevent prototype pollution attacks.

### 4. Static Regex Patterns

**Suppress**: `security/detect-unsafe-regex` and `security/detect-non-literal-regexp` for:

- Static regex patterns (not constructed from user input)
- Patterns with bounded quantifiers (no nested quantifiers)
- Patterns used for parsing known-safe formats (markdown, JSON, etc.)

**Pattern**:

```typescript
// eslint-disable-next-line security/detect-unsafe-regex
// Safe: Static regex pattern for parsing markdown links, bounded quantifiers prevent ReDoS
const LINK_PATTERN = /\[([^\]]+)\]\(\/docs\/([^)#]+)(?:#[^)]+)?\)/g;
```

**Rationale**: Static patterns are not vulnerable to ReDoS attacks.

### 5. Safe Child Process Execution

**Suppress**: `security/detect-child-process` for:

- `execSync()` with static, known commands (not user input)
- Pre-defined command allowlists
- Output that is parsed with static patterns only
- Build/validation scripts where commands are controlled

**Pattern** (JavaScript tooling scripts):

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: execSync runs static known command "pnpm lint", output parsed with static patterns
output = execSync("pnpm lint --max-warnings 0", { encoding: "utf-8" });
```

**Rationale**: Static commands with no user input are safe. Output parsing with static patterns prevents injection attacks.

**When to Fix**: If a script accepts user arguments to a command, validate and escape them before passing to `execSync()`.

## When to Fix

### 1. Unvalidated User Paths

**Fix**: All FS operations with user-provided paths must:

- Go through `validateScopePath()` or similar validation
- Check for path traversal (`..`)
- Reject absolute paths
- Normalize paths properly

**Example**:

```typescript
// ❌ Don't do this
readFileSync(userProvidedPath, "utf8");

// ✅ Do this
validateScopePath(userProvidedPath);
readFileSync(userProvidedPath, "utf8");
```

### 2. Unsafe Regex from User Input

**Fix**: All regex patterns constructed from user input must:

- Validate pattern length (max 200 characters)
- Escape special characters properly
- Check for nested quantifiers that could cause ReDoS
- Use `safeRegExp()` helper from `packages/core/src/security/regex-validator.ts`

**Example**:

```typescript
// ❌ Don't do this
const regex = new RegExp(`^${userPattern}$`);

// ✅ Do this
if (userPattern.length > 200) {
  throw new Error("Pattern too long");
}
const escaped = escapeForRegex(userPattern);
const regex = safeRegExp(`^${escaped}$`);
```

### 3. Unprotected Object Property Access

**Fix**: All dynamic property access with user input must:

- Check for `__proto__`, `constructor`, `prototype` before access
- Use `Object.prototype.hasOwnProperty.call()` for property checks
- Validate keys before accessing

**Example**:

```typescript
// ❌ Don't do this
obj[userKey] = value;

// ✅ Do this
if (
  userKey === "__proto__" ||
  userKey === "constructor" ||
  userKey === "prototype"
) {
  throw new Error("Invalid key");
}
obj[userKey] = value;
```

## Suppression Documentation Requirements

All suppressions must include:

1. **Rule name**: Which security rule is being suppressed
2. **Rationale**: Why the code is safe (internal path, validated input, protection in place)
3. **Reference**: Line numbers or function names where protection/validation occurs

**Good example**:

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Path is typically from getAlignTruePaths().lockfile (safe internal path)
const content = readFileSync(path, "utf8");
```

**Bad example** (missing rationale):

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
const content = readFileSync(path, "utf8");
```

## ESLint Overrides

For files where all operations are known-safe, use file-specific overrides in `eslint.config.js`:

```javascript
{
  files: ["packages/core/src/paths.ts"],
  rules: {
    // All paths from getAlignTruePaths() are safe internal paths (not user input)
    "security/detect-non-literal-fs-filename": "off",
  },
}
```

### JavaScript Tooling Scripts

For build and validation scripts in `scripts/`, override rules when appropriate:

```javascript
{
  files: ["scripts/**/*.mjs", "scripts/**/*.js"],
  rules: {
    // Scripts use static known commands via execSync, parsed with static patterns
    "security/detect-child-process": "off",
    // Scripts use safe internal paths from getAlignTruePaths() or __dirname
    "security/detect-non-literal-fs-filename": "off",
  },
}
```

**Use overrides for**:

- Utility files where all paths are safe
- Test files (if warnings are excessive)
- Tooling scripts where all commands and paths are static/hardcoded
- Files with many safe operations where inline suppressions would be noisy

**Do NOT use overrides for**:

- Scripts that accept command-line arguments
- Scripts that dynamically construct commands or paths
- Scripts that process user input

## Review Process

Before suppressing:

1. Verify the code is actually safe (not just convenient to suppress)
2. Check if validation/protection exists
3. Document the rationale clearly
4. Consider if a fix would be better (e.g., adding validation)
5. For tooling scripts: Ensure commands and paths are static/hardcoded, not derived from user input

## Examples

### Good Suppression

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: Internal schema file path, resolved from __dirname at build time (not user input)
const configSchema = JSON.parse(readFileSync(schemaPath, "utf8"));
```

### Bad Suppression (missing validation)

```typescript
// eslint-disable-next-line security/detect-non-literal-fs-filename
// Safe: User provided path (WRONG - needs validation!)
const content = readFileSync(userPath, "utf8");
```

### Good Fix

```typescript
// Validate user path first
validateScopePath(userPath);
const content = readFileSync(userPath, "utf8");
```

### Tooling Script Example (JavaScript)

**Good suppression**:

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: execSync runs static known command, output parsed with static patterns only
const output = execSync("pnpm lint --max-warnings 0", { encoding: "utf-8" });
const lines = output.split("\n");
```

**Bad suppression** (would need fixing):

```javascript
// eslint-disable-next-line security/detect-child-process
// Safe: executing user command (WRONG - needs validation!)
const output = execSync(userCommand, { encoding: "utf-8" });
```

**Correct approach**:

```javascript
// Validate command against allowlist
const ALLOWED_COMMANDS = ["lint", "test", "build"];
if (!ALLOWED_COMMANDS.includes(userCommand)) {
  throw new Error(`Command not allowed: ${userCommand}`);
}
const output = execSync(`pnpm ${userCommand}`, { encoding: "utf-8" });
```

## GitHub CodeQL Alerts

**Critical distinction**: CodeQL alerts are NOT suppressed with inline comments like ESLint. Use GitHub's security UI to dismiss false positives.

### Why lgtm comments don't work

The `lgtm[rule]` format was used by the deprecated LGTM.com service. Modern GitHub CodeQL does not reliably honor these inline suppressions. Remove any `// lgtm[...]` comments to avoid confusion.

### How to dismiss false positive CodeQL alerts

1. Go to https://github.com/AlignTrue/aligntrue/security/code-scanning
2. Click the alert
3. Select "Dismiss alert"
4. Choose category:
   - **False positive**: Alert is incorrect or code is genuinely safe
   - **Won't fix**: Alert is valid but intentionally not addressed
5. Add justification explaining:
   - Why the alert doesn't apply (validation, safe by construction, etc.)
   - Any safety measures in place

### Batch dismissal workflow

When dismissing multiple related alerts:

1. List alert numbers in ascending order (e.g., #366, #367, #368...) for easier tracking
2. GitHub UI shows alerts newest-first by default; sort by "Alert number" ascending if dismissing many
3. Use consistent justification text across related alerts for maintainability

**Template justification for test fixture temp files:**

> Test fixtures use isolated temp directories with crypto.randomBytes() for unpredictable paths and proper cleanup in afterEach(). Safe by construction per security_linting_policy.mdc.

### Documentation requirement

When dismissing CodeQL alerts, the justification must explain the safety measure:

**Good justification**:

> Temp file uses same-directory pattern with crypto randomness (not OS temp dir). Atomic rename on same filesystem prevents TOCTOU. See packages/file-utils/src/atomic-writer.ts.

**Poor justification**:

> False positive

### Examples of safe patterns that trigger alerts

| Alert                   | Safe Pattern                                         | Why                                                                        |
| ----------------------- | ---------------------------------------------------- | -------------------------------------------------------------------------- |
| insecure-temporary-file | Same-dir temp with crypto randomness + atomic rename | Atomic same-dir operations are always atomic across platforms              |
| http-to-file-access     | Fetch validated URL → write to internal cache path   | URL validated at construction; cache path is internal `.aligntrue/.cache/` |
| file-access-to-http     | Read file for HTTP headers (etag, etc.)              | Headers come from response object, not user input                          |

## Maintenance

- Review suppressions during code reviews
- Update suppressions if code changes
- Remove suppressions if validation is added
- Document new patterns as they arise
- Remove `// lgtm[...]` comments when found (they're ineffective with GitHub CodeQL)

## Extracted from: .cursor/rules/rule_writing.mdc

---

## description: Use this when drafting or updating any Cursor rules.

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Cursor rules authoring guide

## Purpose

Use this when creating or updating any Cursor rule so guidance stays sharp, consistent, and testable.

---

## Output contract when proposing a rule change

Every proposed rule or edit must include:

1. Summary of change
2. Rationale
3. Updated rule text only
4. Impacted areas and precedence notes
5. Tests or examples if relevant
6. Conflict check: rules it supersedes, extends, or defers to

---

## Authoring checklist

- Write for the agent in imperative voice
- One topic per rule; split large topics
- Keep each rule under 500 lines
- State where it applies and where it does not
- Lead with hard constraints (must, never, only)
- Add at least one minimal example for each key directive
- Encode precedence when overlap is possible
- Reference real context with `@Cursor Rules`, `@Docs`, and file paths
- For response shaping rules, define an explicit output contract
- Prefer paved road patterns over generic prohibitions
- Ban known anti patterns directly with short examples
- Keep diffs minimal; avoid full rewrites without cause
- For parameterized, stack agnostic behavior, use plugs (see `plugs.mdc`)

---

## Rule structure

Each rule must follow this shape:

1. **Header**
   - `id`, `version`, `updated`, `owner`, `status`
2. **Title**
   - Short, specific topic name
3. **When this applies**
   - Repo paths, tech stack, scenarios
4. **Constraints**
   - Explicit must, never, only
5. **Patterns**
   - Preferred approaches and paved road flows
6. **Output contract**
   - Required sections for agent replies
7. **References**
   - `@Cursor Rules`, `@Docs`, files in repo
8. **Examples**
   - One good, one bad
9. **Precedence**
   - Which rules it overrides or defers to

---

## Quality bar

Rules must be:

- Clear, concrete, and testable
- Short sentences, minimal jargon
- Free of duplicated guidance across rules

If guidance is duplicated, extract it into one rule and reference it.

---

## Maintenance

- Update rules in the same PR as relevant architectural or workflow changes
- Remove obsolete text instead of stacking exceptions
- Use small, focused diffs
- Treat rules as code: review, test, and version them

---

## Do not

- Do not embed team philosophy or broad narrative
- Do not use vague terms like "clean" or "simple" without criteria
- Do not reference docs generically; use explicit `@` links or file paths

## Extracted from: .cursor/rules/pull_request_standards.mdc

---

## description: Pull request (PR) acceptance criteria and self-check gate

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Pull request standards

**When to apply:** Before marking any user facing feature as complete. Use this as the acceptance gate for all PRs that add or modify behavior.

Every such PR must pass this checklist before merge.

---

## Documentation checklist

Required (unless using the internal code exception below):

- [ ] **API docs** for public APIs  
       `apps/docs/content/04-reference/{feature-slug}.md`
- [ ] **User guide** if users must learn new workflows  
       `apps/docs/content/01-guides/{feature-slug}.md` or `apps/docs/content/03-concepts/{feature-slug}.md`
- [ ] **Example** in `examples/{feature-slug}/README.md` with a runnable smoke block
- [ ] **CHANGELOG.md** updated with a concise entry in the correct section
- [ ] **Temp docs deleted**  
       No `*_STATUS.md`, `*_CHECKLIST.md`, `*_SUMMARY.md`, `*_PHASE*.md`, `*_IMPLEMENTATION.md`, or similar

---

## Example validation

Each example must:

- [ ] Run top to bottom without errors
- [ ] Include a smoke block that prints tool version, seed, and platform
- [ ] Pin randomness (for example `SEED=42`, no `Date.now()` in outputs)
- [ ] Produce byte identical artifacts across two runs in the same environment
- [ ] Show equivalent CLI usage with `aligntrue` commands
- [ ] Link to the relevant API docs near the top
- [ ] Use repo data or small synthetic data only (no downloads)
- [ ] Stay under 30 sections, prefer 10 to 20

---

## API documentation validation

All public symbols affected by the PR must have:

- [ ] One line purpose statement
- [ ] Parameters with types and shapes
- [ ] Return types and shapes
- [ ] Error cases and when they occur
- [ ] Determinism notes when relevant (seeds, hashes, ordering)
- [ ] Minimal example (2 to 5 lines)
- [ ] Links to example, user guide, CLI command, and source

---

## Build and CI validation

Before merge:

- [ ] Docs site builds clean  
       `pnpm --filter @aligntrue/docs build` (or equivalent for the docs app)
- [ ] All cross links between examples, API docs, and guides resolve
- [ ] No references to deleted or renamed files
- [ ] Type checks pass on changed packages  
       `pnpm exec tsc --noEmit -p packages/schema/tsconfig.json -p packages/cli/tsconfig.json`
- [ ] Lint passes  
       `pnpm lint`
- [ ] All tests pass  
       `pnpm test`
- [ ] Determinism gate passes for any byte stable artifact  
       run under `TZ=UTC` and compare hashes

---

## UI package validation

If the PR touches `packages/ui/src/**`:

- [ ] No asset imports (no `.svg`, `.png`, `.jpg`, `.jpeg`, `.gif`, `.webp`)
- [ ] SVGs are inline JSX or data URIs only
- [ ] Linter passes `no-asset-imports-in-ui`
- [ ] All consuming apps build clean  
       for example `pnpm --filter @aligntrue/docs build`
- [ ] Theming uses CSS variables, not hardcoded colors
- [ ] Constraints match `implementation_specs.md` Section 12

---

## Internal code exception path

Use only when code is strictly internal.

All must be true:

- [ ] Code is internal utility, not part of public API
- [ ] No CLI command imports or calls it
- [ ] Comprehensive unit tests exist
- [ ] Type checks pass
- [ ] Module header includes an internal note  
       `/** @internal: rationale */`
- [ ] `CHANGELOG.md` still updated with a short note

Example:

```typescript
/** @internal: hash utility used only by manifest writer */
```

---

## Agent self check before marking "done"

Do not claim completion unless all relevant items below are true.

1. Example (if added) runs twice with byte identical outputs
2. All doc links are clicked locally and resolve
3. Docs build passes without warnings that indicate missing pages
4. No temporary `*_*.md` files remain in root or dev directories
5. `CHANGELOG.md` includes a clear user facing summary
6. All acceptance criteria in this file that apply to the change are satisfied
7. If `packages/ui` changed, zero build constraints are satisfied and enforced

If any single item fails, the feature is not done.

---

## What this prevents

- Features without examples
- Public APIs without documentation
- Non deterministic examples that contradict determinism claims
- Temp docs and status files accumulating in the repo
- Broken cross links and missing pages
- Silent user facing changes without `CHANGELOG.md` entries

---

## Enforcement model

- AI agents must not mark work complete until this checklist passes
- Human reviewers use this file as the PR review contract
- CI should run:
  - docs build
  - type check
  - lint
  - tests
  - determinism checks for stable artifacts

---

## Quick commands

### Full gate (typical baseline)

```bash
TZ=UTC pnpm test
pnpm lint
pnpm --filter @aligntrue/docs build
```

### Determinism spot check for an export

```bash
sha256sum out/export.mdc
sha256sum out/export.mdc
# Hashes must match
```

## Extracted from: .cursor/rules/potential_future_features.mdc

---

## description: Potential future features - deferred ideas and implementation triggers

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Potential future features

This document tracks features that were considered but explicitly deferred. Each entry includes:

- What was deferred and why
- Current approach or workaround
- Clear trigger(s) that indicate when to reconsider implementation
- Estimated effort and implementation notes

**When to use this:** Reference when users request features or when triggers are met.

---

## Permanently removed features

### Catalog as Remote Service

**Status:** Permanently removed - not planned for future

**What was removed:**

- Remote catalog API for rule discovery
- Catalog publishing commands (`aligntrue publish`)
- Catalog-based source resolution
- Centralized catalog website with search/discovery UI

**Why removed:**

- Added unnecessary complexity for solo and team workflows
- Git-based sharing provides sufficient collaboration without central registry
- Local example packs serve documentation needs adequately
- Users prefer direct git URLs over catalog abstraction

**Current approach:**

- Users share rules via git repositories (GitHub, GitLab, self-hosted)
- Example packs in `examples/packs/` provide seed data for documentation
- Direct git URL imports via `aligntrue pull` command

**Not planned:** Remote catalog service will not be reconsidered. All references removed from codebase.

# Growth flywheel and community ignition

- Align discovery: Should there be a way to browse/search aligns?
- Starter packs deliver instant value in common stacks
- Golden repos with public dashboards showing before and after metrics
- Monthly public stats: Top Aligns, new packs, top exporters, drift trends
- RFC process in `/rfcs` with template and voting in GitHub Discussions
- Trust metric: verified authors, adoption count by hash, testkit conformance signal
- Community rituals: weekly “Align Friday” releases; monthly “Top Aligns” blog; `good-first-align` bounties
- Golden repos maintenance: locked by lockfile; weekly bot PR bumps deps and regenerates exports; alert if wow-metrics regress by more than 5%

---

## ☁️ Cloud Strategy and Monetization (Future)

**Status:** Explicitly deferred until adoption demonstrates demand.

**Adoption Trigger:** 100+ active repos OR 25+ organizations actively using AlignTrue + clear demand signal.

**Note:** Cloud is optional. All core workflows (init, sync, check, team mode, CI gates) stay free and OSS forever.

**Objective:** Monetize operational convenience (sync dashboard, approvals UI, org analytics) while keeping policy enforcement and determinism tooling free forever.

### Free vs Paid (Tentative Vision)

| Feature                           | Free (OSS) | Paid (Cloud) |
| --------------------------------- | ---------- | ------------ |
| init, sync, check, export         | ✔         |              |
| Unidirectional sync, watch mode   | ✔         |              |
| Team mode, lockfiles, drift gates | ✔         |              |
| CI validation and SARIF output    | ✔         |              |
| Org sync dashboard                |            | ✔           |
| Scheduled multi-repo PRs          |            | ✔           |
| Approval workflows UI             |            | ✔           |
| Drift analytics and trends        |            | ✔           |
| SSO / RBAC (multi-org)            |            | ✔           |

### Cloud design principles (if built)

- **Zero data at rest** — Cloud never stores private rules or config. Only hashes and minimal metadata.
- **Git is source of truth** — Each org keeps rules in private repos. Cloud coordinates and verifies.
- **Local enforcement** — All policy checks run in CI/CLI. Cloud provides visibility, not gatekeeping.
- **Federated trust** — No org crawl without explicit scope. Repo-scoped tokens. Privacy by default.
- **Open standards** — Use Sigstore, SLSA, SBOM. No proprietary lockdown.

### Implementation (Deferred)

- Stack: Next.js, Vercel, minimal postgres for metadata
- Data retention: 90 days default
- Privacy: transparent, no data sales
- Pricing: per-org or team tier (TBD post-launch)

### Acceptance criteria

- Clear demand from 25+ organizations using AlignTrue
- Pilot program with 3 users showing measurable adoption (drift down, onboarding faster)
- Community feedback supports the vision

---

# Implementing skills

Updated deets: https://chatgpt.com/share/69098bdd-8a90-8001-a52d-89553d13381c

You are Sonnet 4.5 with full repo context. Implement “Skills” as a first-class primitive in AlignTrue, separate from Rules, Claude-compatible, deterministic, and agent-agnostic.

## Objectives

- Add a top-level `skills` config to AlignTrue (declarative).
- Implement a lockfile with commit + hash pinning for reproducible installs.
- Create CLI lifecycle: `install`, `lock`, `read`, `bundle`.
- Update exporters to surface skills in `AGENTS.md` and sync to `.claude/skills/` or `.agent/skills/`.
- Enforce spec validation for `SKILL.md` frontmatter. Note: `allowed-tools` is only enforced by Claude; treat it as advisory elsewhere.

## Guardrails

- Node LTS 20, TypeScript strict, pnpm workspace.
- Don’t touch unrelated code. Keep PR small, cohesive, and fully tested.
- Idempotent file writes with clear markers. No duplicate skill listings.
- Deterministic hashing (JCS where applicable) and stable sort orders.
- Prefer commit SHAs over branches. Fail installs if ref is floating unless `--force`.

## High-level plan

1. **Schema**
   - Edit `packages/schema/schema/align.schema.json` to add a top-level `skills` array referencing a new `$defs.skill_source`.
   - Create `packages/schema/schema/align.skills.lock.schema.json` for `.aligntrue.skills.lock.json`.

   **Targeted addition (trimmed) — align.schema.json**

   ```json
   {
     "properties": {
       "skills": {
         "type": "array",
         "description": "Declarative list of skill sources to install.",
         "items": { "$ref": "#/$defs/skill_source" }
       }
     },
     "$defs": {
       "skill_source": {
         "type": "object",
         "required": ["id", "source"],
         "properties": {
           "id": { "type": "string", "pattern": "^[a-z0-9-]{1,64}$" },
           "source": { "type": "string", "format": "uri" },
           "ref": {
             "type": "string",
             "description": "Tag, branch, or commit; prefer commit SHA."
           },
           "install": {
             "type": "string",
             "enum": ["project", "global", "universal"],
             "default": "project"
           },
           "include": { "type": "array", "items": { "type": "string" } }
         }
       }
     }
   }
   ```

Lockfile sketch — .aligntrue.skills.lock.json

{
"lock_schema_version": 1,
"resolved": [
{
"id": "core-skills",
"source": "https://github.com/anthropics/skills.git",
"commit": "abcdef1234…",
"install": "project",
"skills": [
{ "name": "pdf", "path": ".claude/skills/pdf", "sha256_dir": "…" },
{ "name": "xlsx", "path": ".claude/skills/xlsx", "sha256_dir": "…" }
]
}
]
}

    2.	Core utilities
    •	Add packages/utils/src/hashDir.ts to SHA-256 hash a directory deterministically (stable file order, exclude vcs dirs).
    •	Add packages/core/src/skills/validate.ts to validate SKILL.md frontmatter: name and description required, allowed-tools optional; length and charset checks.
    •	Add packages/core/src/skills/discovery.ts to scan skills using this precedence and dedupe by name:
    1.	./.agent/skills/
    2.	~/.agent/skills/
    3.	./.claude/skills/
    4.	~/.claude/skills/

Highest-priority location wins. 3. CLI
Create new commands under packages/cli/src/commands/skills/:
• install.ts
• Read .aligntrue/config.yaml → skills[].
• Resolve ref to commit (prefer SHA). If branch/tag, resolve to SHA and warn; with --force allow floating.
• Clone/checkout into target:
• project → .claude/skills/ (default)
• global → ~/.claude/skills/
• universal → .agent/skills/ (or ~/.agent/skills/ if global)
• Validate each SKILL.md. Compute sha256_dir. Update lockfile.
• lock.ts
• Resolve and pin refs to SHAs without cloning content changes. Write .aligntrue.skills.lock.json.
• read.ts
• Output normalized SKILL.md to stdout with a header indicating base directory for references/ or scripts/. Mirrors openskills read <name>.
• bundle.ts
• Create deterministic tarball of installed skills + index.json with file hashes for CI distribution.
• Add shared helpers for git checkout, hashing, frontmatter parse.
CLI usage examples

pnpm aligntrue skills lock
pnpm aligntrue skills install
pnpm aligntrue skills read pdf
pnpm aligntrue skills bundle --out dist/skills.tgz

    4.	Exporters
    •	Update packages/exporters/src/agents-md/index.ts to inject an idempotent skills section between markers.
    •	Implement discovery + dedupe. Generate XML block with usage guidance and <available_skills>.

Exact block to write into AGENTS.md

<skills_system priority="1">

## Available skills

<!-- SKILLS_TABLE_START -->
<usage>
When users ask you to perform tasks, check if any of the available skills below can help.
How to use skills (non-Claude agents):
- Invoke: Bash("aligntrue skills read &lt;skill-name&gt;")
- The skill content will load with detailed instructions
- The base directory will be printed for resolving bundled resources
Notes:
- Only Claude enforces `allowed-tools` at runtime. For others, treat it as advisory policy.
</usage>
<available_skills>
  <!-- one line per deduped skill -->
  <!-- <skill><name>pdf</name><description>PDF toolkit…</description><location>project</location></skill> -->
</available_skills>
<!-- SKILLS_TABLE_END -->
</skills_system>

    •	Add/confirm a Claude exporter (e.g., packages/exporters/src/claude/index.ts):
    •	Copy installed skills to .claude/skills/ for the chosen scope.
    •	Optionally support --universal to prefer .agent/skills/.

    5.	Docs
    •	apps/docs: Add “Skills” page with:
    •	What is a Skill vs Rule.
    •	Authoring SKILL.md frontmatter reference.
    •	Install modes: project/global/universal and precedence.
    •	Lockfile semantics and reproducibility expectations.
    •	Security note about allowed-tools.
    6.	Tests
    •	Unit: validate.ts, hashDir.ts, lockfile writer, dedupe logic.
    •	Integration: fixture repo with 2 demo skills; run skills lock → install → read → export.
    •	Golden test: AGENTS.md injection idempotency and dedupe across .agent/ and .claude/.
    •	E2E: pin to SHAs, assert identical hashes on re-install.

Acceptance criteria
• Adding skills to .aligntrue/config.yaml and running pnpm aligntrue skills install installs skills deterministically, writes a lockfile, and pnpm aligntrue sync exports to agents-md with the XML section and no dupes.
• Re-running install/sync is idempotent. No spurious diffs.
• pnpm aligntrue skills read <name> returns normalized SKILL.md and a base dir hint.
• Lockfile pins commit SHAs and per-skill directory hashes; CI re-install reproduces identical hashes.
• Claude exporter syncs to .claude/skills/ or .agent/skills/ based on mode.
• All new code has unit + integration tests and passes lint/typecheck.

Implementation notes
• Use fast-glob with explicit allowlist for hashing; ignore .git, node_modules, editor temp files.
• Normalize frontmatter via a single parser; serialize normalized markdown for read.
• For AGENTS.md, wrap writes with <!-- SKILLS_TABLE_START --> and <!-- SKILLS_TABLE_END -->. On update, replace only the interior.
• Sort skills by name ascending for stable output. In dedupe, highest-priority location wins; lower ones are ignored.
• Make advisory policy text about allowed-tools explicit in non-Claude exporters.
• Keep PR under ~600 LOC net change. Separate commits: schema, utils, CLI, exporters, docs, tests.

Deliverables
• Schema update + new lockfile schema.
• CLI commands: skills lock, skills install, skills read, skills bundle.
• Exporters updated for skills.
• Docs page + examples.
• Full test coverage for new surfaces.

If you want a lighter “start here” prompt later, say the word and I’ll compress this into a one-screen checklist.

# White collar wedge

Target Eng/Dev Managers who want better alignment with the product teams by codifying strategy/goals/priorities in rules as a priorities.mdc.

Make this feature 100% free as part of the corp team version.

⸻

1. Conceptually viable

Yes — alignment beyond code will become a big theme. Most white-collar work is already rule-based (strategy docs, playbooks, OKRs, compliance checklists). Turning those into deterministic, versioned “Aligns” is plausible because:
• Writing and reasoning about rules is native to LLMs.
• Every org struggles with drift between strategy and execution.
• AI introduces compounding misalignment (each agent amplifies gaps).

So the macro thesis — “alignment infrastructure for organizations” — is sound.

⸻

2. But adoption will be nonlinear

Stage Likelihood Why
Dev & AI-ops alignment 90% Verifiable, measurable, direct productivity gain.
Cross-team (PM, design, docs) 60% Feels useful if integrated into existing workflows (GitHub, Notion, Google Docs). Needs low-friction adapters.
Org-wide cultural alignment 25–30% Most companies resist anything that smells like “process policing.” You’ll need strong framing: insight, not surveillance.

Realistically: devs → tech teams → ops → maybe exec layers over ~5 years.

⸻

3. What makes it viable outside dev

You’d need to translate your “rule + lock + drift” model into something that feels natural in business contexts:

Concept Developer version Business version
.aligntrue.yaml aligns for code agents playbooks / policy snippets
drift check CI test quarterly strategy review or live dashboard
lock hash deterministic proof "this doc aligns with Strategy v1.3"
SARIF findings lint results deltas between doc language and declared priorities

If you hide the YAML and surface “alignment scores” or “drift trends,” it could click.

⸻

4. Why it could fail

1. No visible pain at human scale.
   Misalignment hurts slowly, so few teams will install “alignment tools.”
   You’ll need to piggyback on existing motions (PR checks, doc reviews, goal-tracking).

1. Over-surveillance optics.
   Anything that “reads Slack” or “scores alignment” risks backlash.
   Position it as assistive clarity, not compliance monitoring.

1. Context ambiguity.
   Natural language strategy is fuzzy. You can’t measure drift without structured context.
   The model has to enforce structure first (like Asana or Notion databases) before AI can quantify it.

⸻

5. How to make it real 1. Pick a single white-collar wedge.
   e.g. product requirements and engineering roadmaps alignment.
   Build a “strategy lint” that scans docs and flags contradictions with declared goals. 2. Use the same primitives.
   Rules (.aligntrue.yaml), checks (regex, manifest_policy), drift scoring (hash mismatches).
   It’s the same engine, different data adapters. 3. Integrate into daily tools.
   • PR comments → GitHub
   • Doc checks → Google Workspace or Notion API
   • Meeting notes → summary drift check 4. Sell visibility, not control.
   Dashboards showing how teams interpret goals are easier to adopt than enforcement tools.

⸻

6. Viability snapshot

Dimension Outlook
Technical feasibility ✅ Solid (reuses AlignTrue engine)
Market readiness ⚠️ Low near-term, rising as orgs drown in AI chaos
Adoption friction 🔴 High — cultural resistance
Monetization potential 🟢 Strong if you own “alignment analytics” data
5-year TAM realism ~$1–3B if generalized as “alignment observability”

⸻

TL;DR brutal version
• The dev use-case is a lock.
• The org-wide “AI alignment for people + policy” angle is visionary but 3–5 years early.
• You’ll fail if you lead with it; you’ll win if you grow into it via developer traction.
• Success depends on reframing it as clarity tooling, not compliance tooling.

If you can make “alignment” feel like a spell check for decisions, you’ll own that category.

⸻

1. Determinism in coding

In software, determinism is literal — same inputs → same outputs, byte for byte.

Layer Example How AlignTrue enforces it
Config .aligntrue.yaml YAML → JSON (JCS RFC 8785) → SHA-256 hash. Anchors, timestamps, and NaN are forbidden.
Execution Running aln bundle or export cursor Uses stable merge order, sorted arrays, canonical JSON, UTC timestamps, and consistent newlines.
Verification .aligntrue.lock.json and export footer Recomputing hash proves that bundle == lock. Drift = any mismatch.
Measurement SARIF findings or lint results Each check emits deterministic IDs and fingerprints so results are comparable across runs.

→ This makes AlignTrue deterministic by design.
It’s mechanical, measurable, and repeatable — ideal for software because the system’s state space is discrete and bounded.

Why it works:
Source code, configs, and outputs are structured text. You can hash them, diff them, and verify them across time and machines.

⸻

2. Determinism in white-collar work

Outside code, determinism becomes semantic — same intent should produce the same interpretation or decision, even when expressed differently.

Context Deterministic equivalent Practical signal
Product strategy A stable set of priorities and trade-offs Consistent language and weighting in docs, roadmaps, and goals
Policy / compliance Versioned rulebook + proofs Documents and actions referencing the same rule IDs or hashes
Org communication Message alignment Consistent phrasing and emphasis across Slack, decks, and briefs

But here, “outputs” are words, decisions, and judgments — not code.
You can’t hash a meeting. So determinism can’t be absolute; it becomes probabilistic or linguistic determinism:

Given the same rules and context, independent agents (people or AIs) should reach similar conclusions.

That’s the white-collar version of “same inputs → same outputs.”

⸻

3. How AlignTrue could bridge them

Mechanism In code In white-collar adaptation
Rule packs (Aligns) YAML rules for code agents YAML or markdown rules describing company values, decision frameworks, OKRs
Lockfiles .aligntrue.lock.json (hash proof) “Strategy lock” — a signed snapshot of agreed-upon priorities or principles
Drift checks Compare exports to lock Compare new docs or AI-generated text to locked priorities or guidelines
SARIF-style findings Lint errors, autofixes “Strategy lints” — soft warnings like “mentions revenue but omits customer impact (priority #2)”
Fidelity notes “Approximation in exporter” Transparency note: “AI summary diverges 20% from strategic weightings.”

Essentially, AlignTrue’s determinism becomes semantic reproducibility:
you measure how closely actions or text align to a declared rule set.

The math shifts from:

hash(A) == hash(B)

to:

similarity(A, rule_set) ≥ threshold

Same idea — a verifiable measure of alignment — but fuzzier inputs.

⸻

4. The key distinction

Property Coding determinism White-collar determinism
Nature Binary, exact Probabilistic, contextual
Measurement Hash / diff NLP similarity / rule coverage
Error meaning Bug or misconfig Drift or misunderstanding
Proof Cryptographic hash Statistical or linguistic confidence
Tool role Enforcer Advisor / mirror

In software, AlignTrue can enforce determinism.
In org work, it can only approximate and visualize it.

⸻

5. What this means strategically
   • Short term (coding) → Determinism is a product feature. You sell trust and reproducibility.
   • Long term (orgs) → Determinism is a metaphor. You sell insight: “Here’s where we drifted from what we said we value.”

You’re not building a compiler; you’re building an alignment observatory.

⸻

TL;DR
• Coding determinism = cryptographic reproducibility.
• White-collar determinism = semantic consistency.
• Both share the same goal: make alignment visible, measurable, and improvable.

The more structured an org’s knowledge becomes, the closer it gets to the same kind of determinism that AlignTrue already guarantees for code.

1. What “determinism” would mean outside code

In org life, there’s no compiler. You can’t hash a meeting or unit-test a decision.
So determinism stops meaning byte identical and starts meaning interpretation identical:

Given the same strategy, information, and rules, two competent humans (or AIs) should make the same call most of the time.

That’s the white-collar analog of same input → same output.

It’s about predictable reasoning, not identical bytes.

⸻

2. What’s actually deterministic in this context

Layer Analogue to coding What could be deterministic How AlignTrue could enforce it
Strategy rules .aligntrue.yaml Versioned YAML or doc that encodes values, priorities, tradeoffs Hashable strategy align; signed by leadership
Lockfile .aligntrue.lock.json A frozen snapshot of what "aligned decisions" mean at a moment in time "Strategy lock" with checksums + signatures
Drift checks aln check / SARIF Comparing new docs, plans, or decisions to that lock NLP or embedding similarity: score % alignment
Findings Lint results Specific deltas like "mentions growth but not customer impact (priority #2)" Machine check with align ID and evidence
Exports .cursor/rules AI directives derived from strategy ("when summarizing, weigh security>speed") Same YAML → same AI behavior in Slack/Notion bots

So you could think of AlignTrue for orgs as a compiler for intent:
it takes messy language (memos, decks, goals) and checks whether they compile to the declared align.

⸻

3. How it would feel as a knowledge worker

Imagine your company defines a short “Strategy Align”:

id: org/2025-priorities
priorities:

- name: "Customer trust first" # weight 0.5
- name: "Speed of delivery" # weight 0.3
- name: "Efficiency" # weight 0.2
  aligns:
- id: mention-customer
  severity: MUST
  check:
  type: regex
  pattern: "(customer|user|client)"
  scope: "docs/\*_/_.md"
- id: avoid-internal-jargon
  severity: SHOULD
  check:
  type: regex
  pattern: "\\bsynergy\\b|\\bparadigm\\b"
  negate: true

Now every doc, roadmap, or slide you write is checked by an AlignTrue bot.

You'd experience:
• Inline hints: "You mentioned speed but not customer trust — add one example."
• "Alignment score: 0.82 vs last quarter's 0.74."
• A dashboard showing which teams' plans drift most from strategy.
• PR-style suggestions for doc updates ("add customer example per align org/2025-priorities#mention-customer").

It doesn't block you; it mirrors drift — making misalignment visible the same way ESLint makes bad patterns visible.

⸻

4. How it would feel as a manager or exec

You’d see determinism as consistency and traceability across people and AI tools:

Benefit Example
Stable decisions Two teams faced with similar trade-offs make similar calls because they share the same align pack.
Explainable reasoning When something diverges, you can point to "Align X" instead of gut feelings.
Drift metrics Dashboards show which projects are 20% off-strategy (quantified via align coverage).
Version control for intent You can see that this quarter's "lock" changed priorities and who approved it.

So you’d manage by alignment deltas, not opinions.

⸻

5. What’s truly deterministic vs approximate

Dimension Coding determinism White-collar determinism
Data type Code / config Language / decisions
State space Finite Infinite, fuzzy
Verification Hash comparison NLP similarity score
Tolerance 0% difference allowed 10–20% drift tolerated
Failure Bug Misalignment
Proof Cryptographic Statistical

In coding, determinism is absolute.
In white-collar, it’s statistical but trackable — like saying “this doc aligns 87% with declared goals.”

⸻

6. How AlignTrue could make that usable 1. Rule normalization
   Translate values, strategies, OKRs into small, testable rules (regex, embeddings, keyword coverage). 2. Semantic drift scoring
   Each new artifact (doc, email, summary) gets a numeric drift score vs lock. 3. Versioned intent
   Every strategy pack has a hash; any change is explicit and reviewable. 4. Feedback loops
   The system highlights where human behavior diverges from declared priorities.
   (“Team A keeps trading quality for speed despite policy.”) 5. AI-agent alignment
   The same rules feed into AI assistants so their writing and recommendations mirror org intent automatically.

⸻

7. The lived experience of determinism here

Role How it feels day-to-day
Individual You get a "spell check for alignment." It nudges, not nags. You understand what's expected without meetings.
Manager You get objective drift metrics and versioned rationale for changes.
Org Culture becomes codified in small, auditable align pieces. Updates to strategy are propagated like code updates.

It's not "AI policing language."
It's AI linting reasoning — a reproducibility layer for judgment calls.

⸻

8. Limits and truths
   • You'll never get byte-level determinism for human work. The goal is bounded variance, not identical behavior.
   • The metric is confidence: "80% chance this doc follows align pack X."
   • The danger is surveillance optics — must stay opt-in, advisory, transparent.
   • The payoff is massive when applied internally first (product, marketing, compliance) where drift costs real money.

⸻

TL;DR

In code: determinism = same bits.
In business: determinism = same reasoning.

AlignTrue's role outside coding is to give organizations:
• A versioned, testable definition of "how we decide" via aligns.
• A measurable way to see when real life drifts from that intent.
• A feedback loop that keeps both humans and AIs interpreting strategy the same way.

That's what "determinism" would feel like for white-collar work —
not mechanical repetition, but predictable alignment of judgment.

# mem0 Integration

Here’s a backlog-ready cut you can drop in as a future feature.

Feature: Optional Memory Provider (Mem0-compatible)

Goal

Let users opt into persistence for agents without touching AlignTrue’s deterministic path. Memory is a pluggable capability, not a requirement.

Why
• Agents work better when they remember repo norms and workflows.
• Teams still need reproducible CI. Memory must be off by default and never run during validate unless explicitly requested.

Scope
• Add a provider-neutral capabilities.memory block to the Align spec.
• Ship a thin client and CLI to test, seed, and search memory.
• Export configs for MCP and Skills so Cursor or Claude can call memory tools.
• Include advisory checks and a redaction layer.

Non-Goals
• No default activation.
• No writes in CI unless --online is passed.
• No provider lock-in.

Spec change (non-breaking)

capabilities:
memory:
provider: mem0 # future-proof. could be others later
mode: openmemory*local # managed | self_hosted | openmemory_local
endpoint: http://localhost:8765
api_key_env: MEM0_API_KEY
namespace: ${repo.name}
default_ops: [store, search]
policies:
allow: ["non_sensitive_repo_facts"]
deny_patterns: - "(?i)(password|secret|api[*-]?key)"

Deliverables

Area Deliverable Notes
Schema capabilities.memory with enums and formats Backward compatible
CLI aligntrue memory test Connectivity and auth check. Only with --online.
aligntrue memory seed --from <globs> --namespace <ns> Extracts repo facts after redaction and stores them.
aligntrue memory search --q "<query>" --top-k 5 Quick local debugging.
Thin client packages/memory Minimal REST wrapper used by CLI and exporters.
Exporters MCP client config Points to local OpenMemory or hosted Mem0 server.
Skills tools memory.store, memory.search, memory.delete wrappers.
Configs .env.example and memory.config.json Endpoint, namespace, redaction regexes.
Checks memory_policy, memory_connectivity, memory_dryrun Advisory only. Gate behind --online.
Docs “Memory is optional” guide Local-first defaults, security notes, troubleshooting.

Security and governance
• Deny by default. Redact PII and secrets before any store.
• Namespaces scoped per repo or org.
• Clear guidance for local OpenMemory first. Hosted API is optional.

Rollout plan 1. Add schema and feature flag. 2. Implement client and CLI. 3. MCP exporter for local OpenMemory. 4. Skills exporter and config templates. 5. Advisory checks and docs.

Risks and mitigations
• Data leakage from careless seeding → ship deny patterns and require --online.
• State divergence from non-determinism → default off and never in CI by default.
• Vendor drift → provider-neutral interface and small wrapper layer.

Acceptance criteria
• Align file with capabilities.memory validates.
• aligntrue memory test returns provider info when endpoint and key are set.
• seed command shows a redaction preview and only writes with --confirm.
• MCP export produces a working config that agents can use to add and search memory locally.
• CI runs remain unchanged unless --online is set.
• Docs include a one-page “turn it on” guide and a security checklist.

Effort

Band M. Roughly 60 to 90k tokens of implementation and docs.

Open questions
• Default namespace convention. Repo name only or org plus repo.
• Retention policy and max item size.
• Should we support read-only mode for CI smoke tests.

# Deferred features

## Sigstore cryptographic signing

**Deferred from:** Phase 1 verified authorship (Stage 1.4)

**Current approach:** GitHub org validation (packs in `AlignTrue/aligns` are automatically verified)

**Why deferred:** GitHub org validation provides sufficient trust for Phase 1. Sigstore adds complexity without clear demand signal.

**Implementation trigger:**

- External contributors explicitly request cryptographic verification, OR
- 3+ incidents of disputed authorship occur, OR
- Community consensus emerges that GitHub validation is insufficient

**Implementation notes:**

- Every Align would ship with `signatures/sha256-<hash>.sig` (Sigstore keyless)
- CLI `aln verify-signature` would check signature → hash → content
- Backward compatible: unsigned packs remain valid with warning
- See Phase 1 spec in long_term.mdc for full design

---

## Full registry governance (disputes and SLAs)

**Deferred from:** POLICY.md governance (Stage 1.4)

**Current approach:** Minimal viable governance with namespacing, contribution requirements, and yanking process

**Why deferred:** No external disputes yet. Premature process creates friction without value.

**Implementation trigger:**

- First external dispute arises that minimal governance cannot resolve, OR
- 10+ active external contributors participate in the registry, OR
- Community explicitly requests formal dispute resolution process

**Implementation notes:**

- Add dispute resolution process with clear escalation path
- Define maintainer response SLAs (e.g., 48h for CRITICAL, 7d for normal)
- Establish emergency yank procedure with notification requirements
- Consider governance working group or steering committee
- See Phase 1 spec in long_term.mdc for CVE-style advisory system

---

## MCP Server Declarations

**Deferred from:** Phase 2 consideration

**Current approach:** AlignTrue generates MCP config files (`.cursor/mcp.json`, `.vscode/mcp.json`, `.mcp.json`, etc.) but does not declare or manage MCP servers.

**Why deferred:**

- Focus on rule management and validation first (core value prop)
- Server lifecycle management is orthogonal to alignment enforcement
- Security concerns (server configs often contain API keys, internal URLs)
- Users can combine tools: Ruler for server declarations + AlignTrue for rules
- Zero users yet - no validation that this feature is needed

**Implementation trigger:**

- 10+ user requests for MCP server declarations, OR
- Clear use case where server + rules must be atomically synced, OR
- Phase 3 team mode adoption shows need for server standardization

**Implementation notes:**

- Add `mcp.servers` section to config schema
- Support command/args for local servers, url/headers for remote
- Env var interpolation with safety guardrails (`${MCP_TOKEN}`)
- Never store secrets in config files (env vars only)
- No lifecycle management (don't start/stop servers)
- Optional merge strategies (merge vs overwrite existing configs)
- See `docs/mcp-scope.md` for detailed rationale

**Complementary tools:**

- **Ruler:** MCP server infrastructure and declarations
- **AlignTrue:** Rule content, validation, and team alignment
- Both can coexist without conflict

---

## Additional exporter targets

**Deferred from:** Phase 4

**Current approach:** 48 exporters supporting 28+ AI coding agents

**Why deferred:** Prove "one Align to many agents" with multiple exporters. Prioritize based on demand signals.

**Implementation trigger:**

- Clear demand signal for specific agent (e.g., 10+ requests for new agent), OR
- Agent vendor requests integration partnership, OR
- Community contribution meets exporter quality standards

**Implementation notes:**

- Choose exporters based on adoption and request volume
- Capability matrix per exporter as machine-readable JSON
- Loss catalog required for all exporters
- Target <5% loss delta across exporters on golden repos

---

## AI-Assisted Rule Organization

**Deferred from:** Coverage assessment (November 2025)

**Current approach:** Manual categories and tags in catalog. Users organize rules themselves.

**Why deferred:**

- Core authoring workflow works well without AI assistance
- No demand signal yet from users struggling with taxonomy
- Build foundation first, add AI polish when pain is clear
- Zero users yet - no validation that this feature is needed

**Implementation trigger:**

- 10+ user requests for auto-categorization, OR
- Users report taxonomy fatigue or inconsistency, OR
- Phase 4.5 polish iteration prioritizes this feature

**Implementation notes (~45k tokens):**

- Add `aligntrue organize` command with LLM-powered analysis
- Analyze existing rules and suggest categories, tags, and rule IDs
- Interactive mode: present suggestions, user accepts/rejects
- Auto-generate rule IDs following dot-notation conventions
- Batch operations: organize entire rule sets at once
- Integration with markdown authoring for seamless workflow
- Consider local LLM option for privacy (ollama, llamafile)

**User experience:**

```bash
# Analyze existing rules and suggest organization
aligntrue organize --suggest

# Apply suggestions interactively
aligntrue organize --interactive

# Auto-organize with defaults
aligntrue organize --auto
```

**Quality guardrails:**

- Always show diffs before applying
- Require explicit confirmation for structural changes
- Preserve user overrides and customizations
- Log decisions for future reference

---

## Enhanced agent-specific configuration

**Deferred from:** Coverage assessment (November 2025)

**Current status:** Basic export options exist (`export.mode_hints`, `performance` config)

**Current approach:** Global configuration with minimal per-agent customization

**Why deferred:**

- Foundation exists and covers 80% of use cases
- No demand signal for advanced per-agent settings
- Better to document existing capabilities first

**Implementation trigger:**

- 10+ user requests for per-agent customization, OR
- Specific agent requires unique configuration (timeouts, paths, formats), OR
- Phase 4.5 polish iteration identifies this as high-impact

**Implementation notes (~15k tokens):**

- Document existing `export.mode_hints.overrides` and `performance` options
- Extend config schema with per-agent sections:

  ```yaml
  exporters:
    - cursor
    - agents-md

  exporter_config:
    cursor:
      timeout_ms: 5000
      token_limit: 8000
      output_path: .cursor/rules/custom.mdc
    agents-md:
      format: extended
      include_metadata: true
  ```

- Add validation for agent-specific settings
- Update documentation with examples
- Consider agent capability matrix for smart defaults

**Documentation priority:**

- README section highlighting current customization options
- Config reference with all available settings
- Examples for common use cases

---

## Homebrew installation

**Deferred from:** Coverage assessment (November 2025)

**Current approach:** npm/pnpm only (Node ecosystem)

**Why deferred:**

- npm covers majority of target users (TypeScript/JavaScript developers)
- No demand signal from non-Node users
- Can ship quickly when needed

**Implementation trigger:**

- 10+ requests from Python/Ruby/Go developers, OR
- Adoption metrics show friction from npm-only install, OR
- Community contributor offers to maintain Homebrew tap

**Implementation notes (~20k tokens):**

- Create Homebrew tap repository: `AlignTrue/homebrew-tap`
- Formula for `aligntrue` CLI pointing to npm package
- Standard Homebrew formula structure:

  ```ruby
  class Aligntrue < Formula
    desc "AI-native rules and alignment platform"
    homepage "https://aligntrue.ai"
    url "https://registry.npmjs.org/@aligntrue/cli/-/cli-X.Y.Z.tgz"
    sha256 "..."

    depends_on "node"

    def install
      system "npm", "install", *std_npm_args
      bin.install_symlink Dir["#{libexec}/bin/*"]
    end
  end
  ```

- CI automation for formula updates on npm releases
- Installation docs: `brew install aligntrue/tap/aligntrue`
- Consider official Homebrew core submission after validation

**Alternative:** Simple shell script installer as interim solution

---

## Tool-Specific Migration Converters

**Deferred from:** Coverage assessment (November 2025)

**Current approach:** Users manually copy/paste from existing agent files into AGENTS.md, then sync

**Why deferred:**

- Import functionality was removed (users author AGENTS.md directly)
- No clear demand for automated migration converters
- Manual copy/paste covers most migration needs
- Focus on natural markdown authoring instead

**Implementation trigger:**

- 10+ requests for specific tool migration (e.g., "migrate from Ruler"), OR
- Clear user pain with manual migration process, OR
- Partnership with tool vendor for migration path

**Implementation notes (~60k tokens):**

- Add `aligntrue migrate --from=<tool>` command
- Tool-specific adapters in `packages/cli/src/migrations/`
- Supported tools by priority:
  1. Ruler (.rulerrc, ruler.yaml)
  2. Legacy .cursorrules files
  3. Custom .airc or similar formats
  4. IDE-specific settings (VS Code, IntelliJ)
- Migration report showing coverage and manual steps
- Preserve original files with `.backup` suffix
- Interactive mode for ambiguous conversions

**Quality requirements:**

- 90%+ automated conversion rate for common patterns
- Clear documentation of manual steps for remaining 10%
- Validation of migrated rules before applying
- Rollback capability if migration fails

---

## Additional package manager support

**Deferred from:** Coverage assessment (November 2025)

**Current approach:** npm/pnpm (and potentially Homebrew)

**Why deferred:**

- npm + Homebrew covers 90%+ of target users
- Diminishing returns for additional package managers
- Maintenance burden increases with each manager

**Implementation trigger:**

- Specific user base requests it (e.g., Python community wants pip), OR
- Adoption metrics show significant friction from missing package manager, OR
- Community contributor offers to maintain package

**Implementation notes (80k tokens total):**

**pip wrapper (~25k tokens):**

- Simple Python wrapper around npm package
- Published to PyPI as `aligntrue`
- Handles Node.js dependency installation
- Alternative: npx-based launcher

**apt PPA (~30k tokens):**

- Debian/Ubuntu package repository
- `.deb` package with bundled Node.js binary
- Automatic updates via apt
- Requires signing key and repository hosting

**Docker image (~15k tokens):**

- Official Docker Hub image
- Pre-installed with Node.js and CLI
- Useful for CI environments
- Volume mounts for workspace access

**asdf plugin (~10k tokens):**

- Version management integration
- Community-maintained alternative
- Lower maintenance burden

**Priority order:** Homebrew → pip wrapper → Docker → asdf → apt PPA

---

# Deferred technical improvements

This section tracks technical refactoring and infrastructure improvements deferred to Phase 4.5 or later. Items here require a stabilized codebase and should be reviewed when triggers occur.

## Atomic writing abstraction

**Deferred from:** Foundation cleanup review

**Current approach:** AtomicFileWriter used directly in 46 files with slight variations

**Why deferred:** Current pattern is safe and works well. Premature abstraction without usage pain.

**Implementation trigger:**

- Pattern becomes problematic (errors, inconsistencies), OR
- Phase 4.5 stabilization review prioritizes this, OR
- Adding 20+ new file write sites with different patterns

**Implementation notes (~3k tokens):**

- Create `packages/file-utils/src/safe-writer.ts`
- Function: `writeFileSafe(path: string, content: string, options: WriteOptions): Promise<void>`
- Built-in dry-run support, standardized error messages
- Gradually migrate 46 call sites

---

## Validation logic centralization

**Deferred from:** Foundation cleanup review

**Current approach:** Schema validation fairly centralized in packages/schema

**Why deferred:** Already well-organized. Low ROI for further consolidation.

**Implementation trigger:**

- Validation logic becomes scattered across 5+ packages, OR
- Duplicate validation rules found in multiple locations, OR
- Phase 4.5 review identifies validation inconsistencies

**Implementation notes (~5k tokens):**

- Create `packages/core/src/validation/` directory
- Consolidate: `validateRules()`, `validateConfig()`, `validateLockfile()`
- Single source of truth for business rules

---

## Build/CI Optimization

**Deferred from:** Foundation cleanup review

**Current approach:** Simple pnpm recursive scripts, sequential builds

**Why deferred:** No performance issues yet. Build times acceptable.

**Implementation trigger:**

- Build times exceed 5 minutes, OR
- 15+ packages in workspace, OR
- CI costs become significant

**Implementation notes (~5k tokens):**

- Evaluate Turborepo for build caching
- Parallelize package builds where dependencies allow
- Add build-time dependency analysis
- Incremental TypeScript compilation

---

## Mode hints optional enhancements

**Deferred from:** Phase 2 Stage 1 (Step 9a)

**Status:** Core mode hints functionality complete. Optional polish deferred.

**Deferred items:**

- Step 9d: Enhanced import parser with marker pairing (~1.5k tokens)
- Step 9e: Validate command with 9 checks (~2.5k tokens)
- Step 9f: Documentation updates (~0.5k tokens)
- Step 9g: Integration testing (~1k tokens)

**Why deferred:** Core mode hints experiment complete and production-ready. Optional features await user feedback.

**Implementation trigger:**

- 10+ user requests for enhanced mode validation, OR
- Import from AGENTS.md with mode markers shows parser issues, OR
- Phase 4.5 review prioritizes mode hints polish

**Total effort if implemented:** ~5.5k tokens

---

## Execution modes and conditional rules

**Deferred from:** Phase 2 planning discussion (execution modes feedback)

**Current approach:** Static rule exports with hierarchical scopes and applies_to patterns for basic file-based filtering. Phase 2 includes a lightweight mode hints experiment (~6k tokens) to validate demand before considering any investment in execution modes infrastructure.

**Why deferred:** Architecturally sound concept but operationally heavy for current phase. Requires significant infrastructure (conditions engine, loader integration, agent cooperation) without clear user demand yet.

**Implementation trigger:**

- 10+ user requests specifically for conditional rule execution (not just file-based filtering), OR
- Phase 2 adoption reaches 50+ repos showing need for conversation-aware rule injection, OR
- Agent vendors (Cursor, VS Code, etc.) expose APIs for runtime rule injection

**Implementation notes:**

**Schema Extensions (~20k tokens):**

- Add `mode` field: `"always" | "manual" | "intelligent"` with intelligent as default
- Add `conditions` DSL for deterministic triggers:
  ```yaml
  conditions:
    all:
      - language_any: ["typescript", "javascript"]
      - not:
          any:
            - path_glob_any: ["**/*.test.*", "**/__tests__/**"]
            - text_matches_any:
                - pattern: "console\\.log\\("
                  flags: ["i"]
    budget_tokens: 120 # per-rule token limit
  ```
- Profile-level caps: `max_rule_tokens: 1600`, `max_active_rules: 30`

**Loader Responsibility (~40k tokens):**

- AlignTrue becomes the "loader" that enforces execution policies
- Preprocessor model: Evaluate conditions at sync time, export only matching rules
- Runtime integration: MCP server or agent extensions for conversation-aware injection
- Conflict resolution: severity wins, last-writer-wins, token budget enforcement

**Manual Invocation UX (~10k tokens):**

- CLI: `aligntrue apply <rule-id>` or `aligntrue apply --tag logging`
- Agent palette: "AlignTrue: Apply rule..." commands
- Chat triggers: `/align <rule-id>` in agent conversations

**AGENTS.md Round-trip (~5k tokens):**

- HTML comment markers for machine-parseable sections:
  ```html
  <!-- aligntrue:begin id="base.no-console" mode="intelligent" severity="error" -->
  ### No console in production Use `src/lib/logger.ts` instead.
  <!-- aligntrue:end id="base.no-console" -->
  ```
- Enables unidirectional sync while preserving human readability

**Security & Trust (~5k tokens):**

- Sign rule packs, verify on load, allowlist sources
- Audit trail of injected content hashes
- Redact sensitive data in logs

**Testing Requirements:**

- Golden tests: Assert active rule sets and token counts for various repo contexts
- Snapshot tests: Exported files match fixtures with conditional logic
- Conflict tests: Severity tie-breaking and budget enforcement
- Performance tests: Cold/warm cache evaluation times

**Tradeoffs:**

- **Pro:** Solves the core problem of LLM context bloat without requiring agent cooperation
- **Pro:** Deterministic and testable (unlike prompt-based approaches)
- **Con:** Significant complexity increase (~80k+ tokens for full implementation)
- **Con:** Requires agent APIs for runtime effectiveness (preprocessor model as Phase 2.5 compromise)
- **Risk:** Agent vendors may not expose necessary hooks, limiting runtime capabilities

---

# Conditional features (trigger-based)

## Migration framework

**Status:** Not implemented - Waiting for trigger  
**Trigger:** Post-1.0 schema breaking change required

### When to Implement

**DO NOT build until:**

- You reach 1.0 stable release, AND
- You need to ship a breaking schema change, AND
- User impact justifies tooling investment

**Why conditional:**

- Migration framework is ONLY useful for breaking schema changes
- Without breaking changes, users can manually update YAML files
- Building migrations speculatively is premature optimization
- Pre-1.0, schema can iterate freely without migrations
- Post-1.0, many products never need breaking changes

### Scope (When Trigger Met)

**Before implementation, confirm with user:**

- What breaking change is needed and why
- How many user repos would be affected
- Alternative approaches considered (deprecation, aliases, additive changes)
- Decision to proceed with migration tooling (~60k token investment)

**Implementation:** ~60k tokens

1. **IR Versioning System** - 10k tokens
   - `spec_version` migration logic in `packages/schema/src/migrations/`
   - Version adapter interface for schema evolution
   - Migration metadata tracking (from_version, to_version, applied_at)

2. **Migration Framework Core** - 15k tokens
   - Pure JSON transforms (no I/O, no hashing in transforms)
   - Validation sandwich: validate input IR → transform → validate output IR
   - Deterministic, idempotent transforms only

3. **Migration CLI** - 10k tokens
   - `aligntrue migrate --from <v> --to <v> --dry-run` (preview changes)
   - Requires `--write` flag to apply changes (safety)
   - Clear diff preview showing before/after
   - Rollback support via backup before migration

4. **Migration Tests** - 10k tokens
   - Round-trip tests: v1 → v2 → v1 produces identical output
   - Byte-identical transforms for determinism
   - Edge case coverage: empty fields, vendor bags, nested structures
   - Golden migration vectors in `packages/testkit/`

5. **Migration Documentation** - 5k tokens
   - Create `docs/migration-guide.md` with user-facing examples
   - API documentation in `packages/schema/README.md`
   - Troubleshooting common migration issues

### Current status

**No breaking changes planned.** Schema is stable through Phase 4 launch.

If this status changes, update this section with:

- What breaking change is needed and why
- How many users would be affected
- Alternative approaches considered
- Decision to proceed with implementation

---

## Catalog add command (aligntrue add)

**Deferred from:** Phase 4 catalog website completion

**Current approach:** Manual config editing - users must manually add catalog sources to `.aligntrue/config.yaml` and run `aligntrue sync`

**Why deferred:**

- Catalog website built first to demonstrate vision and validate concept
- Core catalog provider exists and can fetch packs from GitHub
- No demand signal yet from users struggling with manual config editing
- Focus on proving catalog discovery works before CLI integration

**Implementation trigger:**

- 10+ user requests for easier catalog pack installation, OR
- Website analytics show high drop-off on install commands, OR
- Phase 4.5 polish iteration identifies this as high-impact

**Implementation notes (~25k tokens):**

- Add `aligntrue add catalog:<pack-id>@<version>` command
- Uses existing `CatalogProvider` to fetch and validate packs
- Automatically adds source to `.aligntrue/config.yaml`
- Runs `aligntrue sync` to generate agent files
- Supports `--dry-run` for preview
- Handles consent flow for catalog access

**User experience:**

```bash
# Add a catalog pack (currently requires manual config editing)
aligntrue add catalog:packs/base/base-global@1.0.0

# This would:
# 1. Fetch pack from AlignTrue/aligns GitHub repo
# 2. Add to .aligntrue/config.yaml sources array
# 3. Run aligntrue sync to export to all agents
# 4. Generate .cursor/rules/base-global.mdc, AGENTS.md, etc.
```

**Current workaround:**

```yaml
# Manual addition to .aligntrue/config.yaml
sources:
  - type: catalog
    id: packs/base/base-global
    version: "1.0.0"
```

**Quality requirements:**

- Byte-identical output to manual config addition
- Clear error messages for pack not found/network issues
- Graceful handling of consent requirements
- Integration tests with catalog provider mocking

---

## Catalog website with discovery UI

**Archived:** November 4, 2025  
**Location:** `archive/apps-web/`

**What was built:** Full Next.js catalog website with discovery page, pack detail pages, search, filters, install flow, share functionality, analytics tracking, and SEO infrastructure. Phase 4 Sessions 2-6 complete with 11 curated packs from `catalog/examples/`.

**Why archived:** Pre-launch simplification to reduce complexity and maintenance overhead. The dual-app setup (web + docs) created:

- Deployment coordination issues
- Broken catalog build references (`temp-build-catalog.mjs`)
- Heavy pre-commit hooks
- Rewrite proxy complexity between apps
- Unnecessary overhead for 11 packs

**Current approach:** Static catalog page in docs site at `/catalog/available-packs` with:

- Nextra card components for visual display
- Collapsible markdown table for alternative view
- Manual updates from `catalog/packs.yaml`
- Links to GitHub source files

**Implementation trigger:**

- **50+ active users** request catalog discovery UI, OR
- **20+ curated packs** exist and manual list becomes unwieldy, OR
- **User-generated pack sharing** becomes a priority feature

**Restoration notes (~120k tokens):**

If restoring, consider these improvements:

1. **Unified app approach** - Integrate catalog into docs site instead of separate app
2. **Simplified build** - Generate catalog JSON at build time, not as separate step
3. **No dual deployment** - Single Vercel deployment, no rewrite proxying
4. **Lighter stack** - Use Nextra's built-in features where possible

**Architecture (if restored):**

```typescript
// apps/docs/app/catalog/[slug]/page.tsx
// Integrate catalog routes into docs app
// Use Nextra's MDX rendering for pack details
// Generate static params from catalog/packs.yaml at build time
```

**Build pipeline (if restored):**

```bash
# Generate catalog JSON during docs build
pnpm tsx scripts/catalog/build-catalog.ts
# Output: apps/docs/public/catalog/*.json
# Consumed by: apps/docs/app/catalog/*
```

**Key features to preserve:**

- Search with Fuse.js (client-side, no backend needed)
- Category and tag filtering
- Agent compatibility matrix
- Install command generation
- GitHub source linking

**What to skip:**

- Separate analytics tracking (use Vercel Analytics)
- Complex share functionality (simple copy-link is enough)
- Separate search index generation (inline in catalog JSON)

**Estimated effort if restored:** ~120k tokens (much less than original due to lessons learned)

**Related files:**

- Archived code: `archive/apps-web/`
- Catalog data: `catalog/packs.yaml` and `catalog/examples/*.yaml`
- Build scripts: `scripts/catalog/build-catalog.ts` (still exists)
- Current static page: `apps/docs/content/catalog/available-packs.md`

---

## User-Generated Rule Sharing Platform

**Deferred from:** Phase 4 catalog completion

**Current approach:** Curated catalog with manual PR process for pack submissions. Basic URL sharing via copy-link functionality.

**Why deferred:** Core catalog and curated content foundation complete. User-generated sharing adds complexity and scale challenges better addressed after launch validation.

**Implementation trigger:**

- 50+ curated packs in catalog with demonstrated adoption, OR
- 10+ user requests for publishing their own rules, OR
- Community shows interest in sharing custom rule sets

**Implementation notes:**

**Phase 4.6: User Publishing MVP (~45k tokens)**

- User namespace schema extensions for catalog
- CLI `aligntrue publish` command with GitHub verification
- Dynamic profile pages at `/catalog/@username`
- Basic social share buttons (Twitter/X, LinkedIn)

**Phase 4.7: Enhanced Discovery (~30k tokens)**

- Pack adoption metrics and trending algorithms
- User reputation system with trust scores
- Advanced sharing with "Copy for [Agent]" buttons
- Cross-agent compatibility matrix on pack pages

**Phase 4.8: Social Features (~25k tokens)**

- Rich social previews (Open Graph, Twitter Cards)
- Pack forking and "Remix this pack" functionality
- Share analytics and engagement tracking
- Optional community features (comments, ratings)

**Architecture Foundation:**

- User packs stored in `catalog/user-packs/@username/`
- Build-time generation of profile pages
- GitHub ownership verification for namespaces
- Trust scores based on GitHub activity and adoption

**URL Structure:**

```
/catalog/@username              # Profile page
/catalog/@username/pack-name     # Pack detail
/catalog/@username/pack-name?agent=cursor  # Agent-specific copy
```

**Key Features:**

- Cross-agent compatibility assurance (leverages existing 48 exporters)
- Automatic profile page generation on publish
- Social sharing with rich previews and pre-filled content
- Easy copying based on user's IDE/agent preference

---

### References

- Zero-users principle: `.cursor/rules/no_premature_backwards_compatibility.mdc`
- Pre-1.0 policy: Schema can iterate freely before 1.0
- Phase execution plans: See archive/ directory for completed phase implementation details

## Extracted from: .cursor/rules/implementation_specs.mdc

---

## description: Implementation specifications

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Implementation specifications

**When to apply:** When implementing or updating features that must be deterministic, reproducible, or compliance grade (IR, lockfiles, bundles, exports, hashing, canonicalization).

These define **what** to build. The **how** is flexible as long as acceptance criteria are met.

---

## Applicability

### Solo mode (default)

- Lockfile off, bundle off
- IR is the single source of truth: `.aligntrue/rules`
- Validation via `aligntrue check` (config and schema validation)

### Team mode (opt in)

- `mode: team` in config
- Enables lockfile, bundle, and drift detection
- CI validation via `aligntrue drift --gates`

---

## 1) Canonical JSON (determinism foundation)

### Why

Lockfiles and manifests must hash identically across machines.

### Requirements

- Canonicalization uses JSON Canonicalization Scheme JCS (RFC 8785)
- UTF-8 without BOM
- No trailing spaces, exactly one trailing newline
- Number serialization handled by JCS specification

### API

File: `packages/schema/src/canonicalize.ts`

- `canonicalizeJson(value: unknown, excludeVolatile?: boolean): string`
- `computeHash(data: string): string` uses SHA-256
- `computeAlignHash(alignInput: string | unknown): string` combines both for aligns

### Used by

- `.aligntrue/lock.json`
- `.aligntrue/bundle.yaml` normalized JSON views in tests
- `manifest.json`
- `versions.json`

### Acceptance

- Same input yields identical `canonicalJson` on Linux, macOS, Windows
- Non finite numbers throw with a clear field path
- `0.123456789` canonicalizes as `0.123457`

---

## 2) Align merge, precedence, and conflicts (team mode)

### Why

Teams need deterministic align composition.

### Requirements

- Merging happens in memory; `.aligntrue/bundle.yaml` is a forward-compatible placeholder not yet persisted to disk
- Dependency order from a topological sort of the align DAG
- **Precedence (first-wins):**
  - Local project rules (`.aligntrue/rules/`) ALWAYS FIRST, ALWAYS WINS
  - First external source listed in config
  - Second external source listed in config
  - ... (in order)
- `priority` field:
  - Higher numeric `priority` wins over default precedence
- Tie break order:
  - `(priority desc, alignId asc, ruleId asc, sourcePath asc, lineNumber asc)`

### Merge semantics

- Scalars: first wins (when source conflict)
- Set like arrays: union, then stable sort by value
- Maps: deep merge using the same precedence rules

### Outputs

- `.aligntrue/bundle.yaml` merged rules
- `.aligntrue/lock.json` pins:
  - align hashes
  - bundle hash
  - relevant tool versions

### Acceptance

- Identical inputs produce identical bundle and lockfile bytes
- Source rule order does not matter unless it changes defined precedence
- No nondeterministic iteration in merges

---

## 3) Scope matching and glob semantics

### Why

Stable file targeting across OS and tools.

### Requirements

- Normalize paths to forward slashes
- Base directory is repo root
- POSIX style globs, case sensitive
- Default excludes:
  - `node_modules/**`
  - `.git/**`
- Most specific match wins
- On equal specificity, apply Section 2 precedence

### Acceptance

- Same repo yields identical scope resolution on Linux, macOS, Windows
- Most specific scopes applied correctly for monorepo rule assignment

---

## 4) Telemetry (not currently implemented)

### Why

Collect coarse usage signals without leaking data.

### Status

This feature was removed in favor of a simpler approach. See CHANGELOG.md for details on removal.

---

## 5) Export formatting invariants

### Why

Agent exports must be deterministic and readable.

### Markdown style exports

Includes: `.mdc`, `AGENTS.md`, and other markdown based agent formats.

**Requirements:**

- Fixed, documented section order
- `\n` line endings
- Exactly one trailing newline
- No timestamps or UUIDs
- No content hash or fidelity footers in exported files (see note below)
- Include the standard read-only marker so users edit `.aligntrue/rules/`

### AGENTS.md exporter

- Follows the `AGENTS.md` spec
- Uses read-only markers; no content hash or fidelity footers
- Supports link-based or inline content (see content mode)

### Content mode for single-file exports

Single-file exporters (AGENTS.md, CLAUDE.md, etc.) support content mode control:

**Options:**

- `auto` (default): Inline for 1 rule, links for 2+ rules
- `inline`: Embed full rule content with HTML comment separators
- `links`: Always use markdown links to `.aligntrue/rules/` files

**Requirements:**

- Size warning when inline content exceeds 50KB
- Deterministic output regardless of mode
- Links mode preserves relative paths to source files

### Content hash and fidelity handling

**Important:** Content hashes and fidelity notes are NOT embedded in exported files.

**Instead:**

- Content hash is returned in `ExportResult.contentHash` for programmatic use
- Fidelity notes are returned in `ExportResult.fidelityNotes` and displayed by CLI
- Agent files contain only the read-only marker; no hashes or fidelity notes

See `packages/exporters/src/base/EXPORTER_POLICY.md` for complete policy.

### MCP and config exporters

- Write deterministic JSON or YAML
- Stable key ordering
- No volatile fields that change per run
- Content hash returned in `ExportResult`, not embedded in file

### Acceptance

- Same IR yields identical bytes across runs and OSes
- When mapping is partial, fidelity notes are returned in `ExportResult.fidelityNotes`
- Exported files include only the read-only marker as AlignTrue metadata; otherwise clean and user-editable

---

## 6) Schema validation

### Why

Catch errors early.

### Requirements

- Single JSON Schema: `packages/schema/schema/align.schema.json`
- Ajv in strict mode with `allErrors: true`
- Error shaping:
  - Includes JSON path
  - Includes expected vs actual types

### CLI

- `aligntrue check` validates config and rules

### Acceptance

- Invalid configs exit with code 1 and clear messages
- Valid configs pass quietly or with structured output under `--json`

---

## 7) CLI exit codes and error shape

### Exit codes

- `0` success
- `1` validation error (validation failures, sync errors, etc.)
- `2` user error (missing files, bad flags, config errors)

### Error format

Each error must state:

1. What failed
2. Why it failed
3. How to fix it, with a concrete action

### Acceptance

- Contract tests cover `validate`, `bundle`, `export`, `align` exit codes and messages
- Exit codes follow the two-tier system (1 for data/logic errors, 2 for input/config errors)

---

## 8) IR and vendor bags

### Why

IR is canonical. Vendor bags enable lossless multi agent support.

### Requirements

- Canonical source:
  - `aligntrue.yaml` or `.aligntrue/rules` for IR
- Vendor bags:
  - Use `vendor.<agent>` namespaces
- Volatile fields:
  - Stored in `vendor._meta.volatile` array (list of dot-notation paths to exclude from hashing)
  - Example: `vendor._meta.volatile: ["cursor.session_id", "claude.temp_token"]`
- Round trip:
  - IR → agent → IR keeps semantics

### Hashing

- Compute hash on IR with volatile fields removed (via `filterVolatileVendorFields`)
- Use `canonicalJson` then `stableHash`

### Acceptance

- IR → Cursor → IR preserves semantic and vendor data, except declared volatile fields
- IR → AGENTS.md → IR preserves semantics and reports any loss
- Volatile changes do not change hash
- Semantic changes do

---

## 9) Unidirectional sync: rules → agents

### Why

Single source of truth prevents conflicts and ensures predictable behavior.

### Requirements

**Sync direction (only direction):**

- `.aligntrue/rules/*.md` is the single source of truth
- `aligntrue sync` reads from `.aligntrue/rules/`, writes to agent-specific exports
- Agent files (`.cursor/rules/*.mdc`, `AGENTS.md`, etc.) are read-only exports
- Never sync agent files back to IR

**Edit workflow:**

1. User edits `.aligntrue/rules/*.md`
2. User runs `aligntrue sync`
3. Changes flow: `.aligntrue/rules/` → IR → agent exports
4. Agent files updated atomically
5. No user interaction or prompts

**Manual edits to agent files:**

- Detected via SHA-256 checksum comparison
- Backed up to `.aligntrue/overwritten-rules/` with timestamp
- Overwritten without prompting on next sync
- User should edit `.aligntrue/rules/` instead

**Team mode governance:**

- Use lockfile validation (`aligntrue drift --gates`) for approval workflows
- Team lead manages via `aligntrue team approve`
- CI validates against approved hashes
- Lockfile pins IR hashes, not agent file hashes

### Atomicity

- All or nothing writes
- Use temp files and atomic rename
- On failure, leave previous state untouched

### Dry run

- `--dry-run` prints planned changes
- Shows which files would be written
- No files actually modified

### Acceptance

- Plain `aligntrue sync` is deterministic and requires no user interaction
- Same `.aligntrue/rules/` input produces identical agent exports across runs and machines
- Manual edits to agent files are backed up and overwritten
- Team governance via lockfile, not per-file conflicts
- Agent files never contain unsaved user edits

---

## 10) Hierarchical scopes

### Why

Monorepos need path aware rules.

### Requirements

- Scope entries:
  - `path`
  - `include` / `exclude` globs
  - `rulesets`
- Merge order:
  - `[root, path, local]`
- Most specific scope wins
- Ties resolved by merge order
- Exporters support per scope outputs where relevant

### Acceptance

- Scope resolution is deterministic across machines
- Per scope exports match resolved rules
- Conflicts produce actionable errors

---

## 11) Supply chain and releases

### Requirements

- No floating ranges for release builds
- Generate CycloneDX SBOM for tagged releases
- Attach checksums
- CI audits dependencies
- High severity requires explicit waiver

### Acceptance

- Release artifacts verifiable from SBOM and checksums

---

## 12) @aligntrue/ui constraints

### Why

Zero build ESM package must work across apps without special loaders.

### Forbidden

- Importing asset files (`.svg`, `.png`, `.jpg`, `.jpeg`, `.gif`, `.webp`, etc.)
- Using `require()` for assets
- Relying on Next.js loaders or bundler specific behavior

### Required

- Inline SVGs as JSX
- Images as data URIs if needed
- Theming driven by CSS variables
- TypeScript and React only

### Acceptance

- No asset imports in `packages/ui/src/**`
- Custom lint rule catches violations
- Consumer apps build without extra config
- Snapshot tests cover rendering

---

## Implementation guidelines

- Read the relevant sections before coding
- For JSON outputs, always use `canonicalJson` and `stableHash` where determinism is required
- Write acceptance style tests linked to the specs above
- Document discretionary choices inline
- For UI changes, keep to the zero build and no asset import constraints

---

## Review checklist

Before merging a feature that touches determinism, sync, or exports:

- Uses `canonicalJson` and `stableHash` where required (Section 1)
- IR first: IR remains the canonical source (Section 8)
- Vendor bags used and volatile fields excluded correctly (Section 8)
- Unidirectional sync follows precedence and atomicity rules (Section 9)
- Merge order and precedence follow Section 2 in team mode
- Scope behavior matches Sections 3 and 10
- Export bytes are stable and do NOT include content hash or fidelity footers in files (Section 5)
- CLI exit codes and messages follow Section 7
- `@aligntrue/ui` obeys zero build rules if touched (Section 12)

## Extracted from: .cursor/rules/guardrails.mdc

---

description: OSS repo/content guardrails (no leaking future phases or monetization details)
alwaysApply: true

---

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# OSS repo and content guardrails

## Keep future and commercial details private

Do not generate, insert, or reference:

- Future phases beyond the current OSS scope (cloud services, dashboards, org workflows, integrations)
- Monetization details (pricing, revenue, paid tiers, consulting)
- Competitive positioning (comparisons, market claims, investor angles)
- Internal roadmap (timelines, gated milestones, GTM plans)
- Speculative features not explicitly part of the current OSS release

If unsure, omit.

---

## Public repo focus

Keep all public content centered on:

- Determinism, reproducibility, auditability, transparency
- Current OSS features and direct user benefits
- Example packs, schema validation, bundling, lockfiles
- Exporters, CLI usage, MCP server basics
- Local first workflows and offline usage

Use neutral, factual language. Safe phrasing:

> Future improvements may come via community contributions.

---

## Naming and scope

- Project name: **AlignTrue** (no space)
- Public repo: `AlignTrue/aligntrue` (MIT CLI, docs, examples)
- Do not mention `AlignTrue/cloud` or any paid offering in OSS docs, comments, or examples

---

## Safe topics

Allowed focus areas include:

- Deterministic bundles and lockfiles
- JSON canonicalization and hashing
- Exporter fidelity notes and agent parity behavior
- CI validation flows
- Local, offline compatible usage

---

## Out of scope topics

Do not include:

- SSO, approvals, analytics, or multi tenant features
- Team usage analytics, billing, or payment flows
- Comparisons against vendors or tools
- Investor materials, pitch framing, or narrative
- Roadmaps or timelines framed as commitments

---

## Honesty rule

- Do not make claims that are not currently true
- If details are sensitive, undecided, or future oriented, omit rather than speculate

---

## Review checklist

Before merging any OSS docs, README updates, or comments:

- [ ] Mentions only current OSS features and behavior
- [ ] No pricing, roadmap, or enterprise feature details
- [ ] Neutral, factual tone with clear user value
- [ ] AlignTrue naming and repo references are correct
- [ ] Commands and examples run locally with no cloud dependency

---

## Allowed boilerplate

**Positioning (safe)**

> AlignTrue compiles rules into deterministic bundles and agent-ready exports. The CLI validates schemas, pins hashes, and writes stable outputs for CI.

**Future note (safe)**

> Additional improvements may arrive through community contributions. This repository documents the current OSS surface.

---

## Prohibited boilerplate

Do not use phrases like:

- "Enterprise roadmap includes..."
- "Pricing starts at..."
- "This will beat competitors because..."
- "Planned Qx release will add..."

---

## Issue and PR hygiene

- Scope issues and PRs to OSS features:
  - validate
  - bundle
  - export
  - schema
  - examples
- Link to specs and tests instead of future plans
- Keep discussion on current implementation and acceptance criteria only

## Extracted from: .cursor/rules/global.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Global Principles

Keep the codebase stable, safe, and maintainable.

Match the existing style, patterns, and conventions in this project. Prefer minimal, targeted changes over large rewrites. Make your reasoning and tradeoffs explicit.

When you are unsure or information is ambiguous, stop and ask for clarification.

## Code Quality

- Keep functions and modules focused. Avoid "god objects" and overly complex functions.
- Use clear, simple code over cleverness.
- Preserve public APIs and existing behavior unless explicitly asked to make breaking changes.
- Avoid unnecessary meta-programming and "magic" that hides control flow or behavior.

## Correctness and Safety

Follow these priorities:

1. Correctness
2. Security and safety
3. Maintainability and clarity
4. Performance

## Change Hygiene

- Prefer small, coherent changes.
- Group related edits together.
- When you touch a file, clean up nearby small issues only if safe and related to the change.
- Use clear commit messages explaining what changed and why.

## Extracted from: .cursor/rules/error_lessons_learned.mdc

---

## description: Lessons learned from resolving errors and issues

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Error resolution lessons learned

## Build race condition & PowerShell quoting (November 12, 2025)

**Symptoms:**

- `Cannot find module '@aligntrue/core'` (Linux/macOS)
- `No projects matched the filters` (Windows only)
- `Failed to resolve entry for package "@aligntrue/schema"`

**Root Causes:**

- Parallel build race: packages building simultaneously despite dependencies
- PowerShell treats single quotes literally (unlike bash)
- Dependency chain not fully sequenced

**Patterns to Recognize:**

1. **Module not found but package exists:** Check build ordering in `build:packages` and `typecheck` commands
2. **Works on Unix, fails on Windows:** Look for quoted package names in pnpm filters
3. **Build passes, typecheck fails:** Ensure identical dependency ordering in both commands

**Fix Applied:**

Now using Turbo with explicit filters to handle ordering:

```json
"build:packages": "turbo run build --filter='./packages/*'"
```

Turbo automatically respects `package.json` dependencies and parallelizes work correctly without race conditions.

**Key Insights:**

- Use `&&` for explicit sequential stages
- No quotes around package names in pnpm filters
- Test cross-platform locally with `node scripts/pre-ci.mjs`
- "No projects matched" = quoting issue on Windows

**Prevention:**

- Test `-r --filter` commands locally with real package names
- Avoid single quotes in pnpm filter names
- Mirror build stages exactly in typecheck command
- Monitor changes to `package.json` build scripts and package dependencies

## Windows path separators & glob output (November 13, 2025)

**Symptoms:**

- `AssertionError: expected [ Array(2) ] to deeply equal [ Array(2) ]` (Windows CI)
- Expected: `"rules/arch.md"` (forward slashes)
- Actual: `"rules\\arch.md"` (backslashes)

**Root Causes:**

- `glob` library returns OS-native path separators (backslashes on Windows)
- Code directly uses glob output without normalizing to forward slashes
- Local pre-CI does not catch platform-specific path issues

**Patterns to Recognize:**

1. **Test fails only on Windows CI, not locally (macOS/Linux):** Look for path comparisons or manipulations that assume forward slashes.
2. **Path string mismatch (`/` vs `\`):** Indicates a platform-specific path separator issue.
3. **Glob returns unexpected paths:** Confirm whether glob is configured to return normalized paths or OS-native paths.

**Fix Applied:**

```typescript
// Normalize to forward slashes for cross-platform consistency
matches = matches.map((p) => p.replace(/\\/g, "/"));
```

**Key Insights:**

- Always normalize paths from external libraries (like `glob`) to a consistent format (e.g., forward slashes) for cross-platform reliability.
- Platform-specific issues (like path separators) require testing on target platforms (e.g., Windows CI) as local pre-CI may not detect them.
- A small `setTimeout` delay can sometimes resolve race conditions with filesystem readiness in tests (e.g., before calling `glob`).

**Prevention:**

    - Implement a custom path normalization utility in `packages/file-utils` for all path-sensitive operations.
    - Add specific unit tests for path handling with both Windows and Unix path formats, potentially using test data with mixed separators.
    - Document path normalization conventions in `documentation.mdc` and `testing.mdc` for all developers.
    - Consider adding a Windows environment to local development or more robust CI setup that emulates Windows filesystem behavior.

## Confusing "dual setting" configuration bug (November 23, 2025)

**Symptoms:**

- Spinner stuck on "Resolving sources" during interactive prompts (non-verbose mode only)
- Configured multi-file rules (`edit_source: .cursor/rules/*.mdc`) not loaded into IR
- Sync works but generates default rules instead of loading existing ones

**Root Causes:**

- **Two separate settings:** `edit_source` (watching) and `source_files` (loading) were distinct but related concepts.
- **Documentation mismatch:** Docs claimed `source_files` was derived from `edit_source`, but no code implemented this logic.
- **Spinner bug:** `spinner.stop()` was wrapped in `if (verbose)` block, causing infinite spinner during prompts in default mode.

**Patterns to Recognize:**

1. **Configuration drift:** Two settings controlling related behavior will eventually diverge or conflict.
2. **Stuck spinner:** If a spinner persists during prompts, check if `stop()` is conditional on verbosity.
3. **Silent failure:** If valid files are ignored without error, check if the loading logic is actually triggered by the config.

**Fix Applied:**

- **Unified Concepts:** Removed `source_files` entirely. Made `edit_source` the single source of truth for BOTH watching and loading.
- **Logic Update:** `edit_source` with glob patterns now automatically triggers multi-file loading logic.
- **Spinner Fix:** Moved `spinner.stop()` outside conditional block to ensure UI always cleans up before prompts.

**Key Insights:**

- **Single Source of Truth:** Avoid splitting related configuration into multiple fields. One setting is harder to mess up.
- **Trust but Verify Docs:** Documentation claiming "automatic derivation" must be backed by code.
- **UX State Management:** Spinners must always stop before handing control to the user (prompts), regardless of logging level.

## Extracted from: .cursor/rules/documentation.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Public API Documentation

Public API exports should include JSDoc comments explaining their purpose and usage. This helps with IDE intellisense and documentation generation.

## Extracted from: .cursor/rules/debugging.mdc

---

description: Debugging workflow
alwaysApply: true

---

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Debugging workflow

**When to apply:** Investigating bugs, unexpected behavior, test failures, or non-deterministic outputs. Use this before making code changes.

## Core principle

**Diagnose first, fix second.** Symptoms lie. Contracts and data flow do not.

---

## Top 5 time-wasters to avoid

1. Pattern matching fixes that "look like last time"
2. Fixing symptoms (exporter) when root cause is upstream (bundle/lock/schema)
3. Assuming examples and quickstarts are correct
4. Ignoring environment drift (TZ, Node, OS, CI)
5. Trial and error edits without a hypothesis

If you catch any of these: stop and read the error literally.

---

## Investigation framework

### 1. Read the error literally

```
UndefinedError: 'object' has no property 'contentHash'
```

Extract facts:

- Type: object
- Missing: contentHash
- Suspect: shape/contract mismatch

Ask: Why is the key missing? Not "How do I access it differently?"

### 2. Trace the data flow

Map source → transforms → destination.

```
load config → resolve packs → bundle → build context → exporter (error)
↑
Likely fix lives here
```

Answer:

1. Where does the data originate?
2. What transforms it?
3. What does the consumer expect?
4. Where do actual vs expected diverge?

### 3. Inspect actual state

Do not guess. Log the real shape. Remove logs before commit.

```typescript
const log = (o: unknown) => {
  console.debug("type:", Array.isArray(o) ? "array" : typeof o);
  try {
    console.debug("preview:", JSON.stringify(o, null, 2).slice(0, 2000));
  } catch {}
};
log(ctx);
```

### 4. Compare expected vs actual

```typescript
// Expected
const expected = { contentHash: "sha256:...", rules: [] };

// Actual
const actual = {
  hash: "sha256:...",
  rules: [],
  meta: { contentHash: "sha256:..." },
};
// Root cause: contentHash nested under meta instead of top level
```

Fix the transformation or normalization, not templates or call sites that already match the contract.

### 5. Identify the root cause

Keep asking "why" until you hit a contract boundary:

- Symptom: exporter missing contentHash
- Why: context builder never flattened metadata
- Why: bundle layout changed, normalization not updated
- Root cause: missing normalization step
- Fix: add normalization in shared context builder

### 6. Fix at the right layer

Use this matrix:

| Situation                                | Fix location               | Reason                |
| ---------------------------------------- | -------------------------- | --------------------- |
| Nested vs flat mismatch across consumers | Normalization/shared layer | One source of truth   |
| One consumer needs special format        | That consumer              | Localize special case |
| Shared contract used by many             | Shared helpers             | Consistency and DRY   |

### 7. Verify the fix

Prove the contract, do not just silence the error.

```typescript
expect(ctx.contentHash).toMatch(/^sha256:/);
expect(bytes(exportMdc(ctx))).toStrictEqual(bytes(exportMdc(ctx)));
```

Checklist:

- Error is gone
- Root cause understood and documented
- Correct layer changed
- Contract test added to prevent regression

---

## Common anti-patterns

- "Fix and see" loops
- Copying old fixes based on similar messages
- Only reproducing via full system runs (no minimal repro)
- Treating docs/examples as ground truth without verifying
- Token churning: repeated edits without fixing the underlying contract

If you see this pattern, reset to the investigation framework above.

---

## CI Failures

For troubleshooting CI issues, always follow the guidance in `.cursor/rules/ci_troubleshooting.mdc` to conserve API rate limits.

Key command: `pnpm ci:errors`

---

## Git safety

Always stash before destructive operations.

```bash
git stash push -m "WIP: <desc>"
git checkout <branch>   # or git switch/reset
# ... investigate ...
git stash pop
```

Never:

- Run git checkout or git reset with uncommitted changes without stashing
- Assume uncommitted work is recoverable

If you did it anyway:

1. `git reflog`
2. `git stash list`
3. `git fsck --lost-found`
4. If still lost, rebuild. Prevention is cheaper.

---

## Recognizing and stopping token churning

Churning = burning tokens on repeated edits without fixing the underlying contract.

Warning signs:

1. Same type of tweak 3+ times in a row
2. Bulk search/replace before proving pattern
3. Editing tests to match outputs instead of fixing behavior
4. Fighting mocks instead of understanding code under test
5. Huge token use, small actual progress

Reset with three questions:

1. What pattern am I repeating?
2. What is the actual contract or behavior?
3. Which single layer is wrong?

Then:

1. Fix one representative case end to end
2. Confirm with tests
3. Apply the proven pattern once across the rest

---

## Environment checks

Run these early:

```bash
TZ=UTC pnpm test

node -v
pnpm -v

# Canonical diff
jq -S . out1.json > a && jq -S . out2.json > b && diff -u a b || true

# Nondeterminism scan
rg "Date\.now|Math\.random|performance\.now" packages/schema/src packages/cli/src packages/core/src
```

---

## OS-specific behavior

Before touching code, check if the failure is platform specific.

Common differences:

| Area         | Unix           | Windows          | Strategy             |
| ------------ | -------------- | ---------------- | -------------------- |
| Permissions  | chmod reliable | chmod unreliable | Skip or branch tests |
| Spawn time   | Faster         | Slower           | Higher thresholds    |
| Paths        | `/`            | `\`              | Use path.\* helpers  |
| Line endings | `\n`           | `\r\n`           | Normalize in tests   |
| Temp dirs    | `/tmp`         | `C:\...`         | Use os.tmpdir()      |

If CI fails only on Windows:

- Read error literally
- Check for assumptions about paths, chmod, timing
- Decide: real bug vs platform specific test
- Fix once at correct layer

---

## Minimal repro pattern

Use tight, focused tests.

```typescript
test("context exposes contentHash at top level", () => {
  const merged = { rules: [], meta: { contentHash: "sha256:abc" } };
  const ctx = normalizeContext(merged);
  expect(ctx.contentHash).toBe("sha256:abc");
});
```

Run:

```bash
pnpm --filter @aligntrue/schema vitest run packages/schema/tests/context.contract.test.ts -t contentHash -v
```

---

## Logging guidelines

- Log what happened and how to fix it
- Do not log secrets or token-like values
- Prefer structured logs behind `--json` when helpful
- Strip debug logs before merge

---

## AlignTrue quick reference

| Error pattern                    | First check            | Likely cause        | Fix location                                      |
| -------------------------------- | ---------------------- | ------------------- | ------------------------------------------------- |
| Lockfile bytes differ            | canonicalizeJson usage | Missing JCS or sort | packages/schema/src/canonicalize.ts               |
| Missing or wrong exporter footer | Context contentHash    | Not flattened       | packages/cli/src/commands/sync/context-builder.ts |
| aligntrue --help slow            | Import graph           | Eager imports       | packages/cli/src/commands/\*.ts                   |
| Pass local, fail CI              | TZ/Node drift          | Env mismatch        | Vitest setup, CI config                           |
| Scope mismatch on Windows        | Path normalization     | Slash handling      | packages/core/src/scope.ts                        |
| Ajv errors unreadable            | Error shaping          | Missing formatter   | packages/core/src/validation/\*.ts                |

---

## Determinism triage

```bash
# 1. Canonical compare
jq -S . bundle1.json > b1 && jq -S . bundle2.json > b2 && diff -u b1 b2 || true

# 2. Nondeterminism search
rg "Date\.now|Math\.random|performance\.now" packages/schema/src packages/cli/src packages/core/src

# 3. Stable sets
# Ensure set-like arrays are sorted once in canonicalization
```

---

## Temp artifacts

All temporary debug artifacts must start with `temp-`.
Never commit temp files.

---

## Communicate the fix

In PR or commit message:

- Root cause in one sentence
- What changed and where
- How tests now enforce the contract
- Any platform or determinism notes

---

# Error Lessons Learned Reference

- For troubleshooting complex or recurring errors, consult `.cursor/rules/error_lessons_learned.mdc`—it contains past solutions and root causes.
- When you solve a tricky or non-obvious error, summarize the problem, root cause, and successful fix in `error_lessons_learned.mdc`.
- Write entries in a clear, concise, and structured way (e.g., Symptoms → Cause → Resolution) to help both humans and AI tools diagnose similar issues in the future.

## Extracted from: .cursor/rules/ci_troubleshooting.mdc

---

description: Guidance for troubleshooting CI/CD failures and checking GitHub Actions status
globs:

- .github/workflows/\*.yml
- scripts/check-ci-errors.mjs
- scripts/check-codeql-status.mjs

---

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# CI Troubleshooting and Status Checking

**When to apply:** The user asks about CI status, why a build failed, or requests to check GitHub Actions/Workflows.

## Core Principle

**Conserve API Rate Limits.** AI agents and scripts can easily hit GitHub API rate limits (60/hr unauthenticated, 5000/hr authenticated). Always prefer local verification and efficient API usage.

## Troubleshooting Workflow

Follow this priority order when investigating CI issues:

### 1. Local Reproduction (Zero API Cost)

Always attempt to reproduce failures locally first. This is faster and uses no API quota.

```bash
# Run the full validation suite (matches CI)
pnpm validate:all

# Or specific checks
pnpm test               # Unit tests
pnpm build:packages     # Build
pnpm lint               # Linting
```

### 2. CI Error Details (Low API Cost)

If local checks pass but CI fails, fetch actual error details directly:

```bash
# Fetches the most recent failed CI run and displays error details
pnpm ci:errors
```

This shows test failures, assertion errors, and other actionable details in one command.

### 3. Code Scanning & Security Alerts (Low API Cost)

If you need to check GitHub code scanning (CodeQL) alerts:

```bash
# Check code scanning alerts and security issues
pnpm codeql:status
```

This efficiently fetches and displays alerts by severity, with direct links to review them.

### 4. Web UI (Fallback)

If rate limits are hit or complex debugging is needed, direct the user to the browser:

- **Actions Tab:** https://github.com/AlignTrue/aligntrue/actions
- **Current Branch:** https://github.com/AlignTrue/aligntrue/actions?query=branch%3A<branch-name>
- **Code Scanning:** https://github.com/AlignTrue/aligntrue/security/code-scanning

## Anti-Patterns to Avoid

- ❌ **DO NOT** run `gh run list` repeatedly in a loop.
- ❌ **DO NOT** use `gh api` for simple status checks without checking rate limits.
- ❌ **DO NOT** assume CI failure implies code error; check for flakes or infrastructure issues.
- ❌ **DO NOT** blindly retry CI jobs without understanding the failure.

## Rate Limit Awareness

If you encounter `API rate limit exceeded` or HTTP 403/429 errors:

1.  Stop making API calls immediately.
2.  Direct the user to the Web UI.
3.  Explain that the rate limit was hit.

## Integration

- **CI Workflow File:** `.github/workflows/ci.yml` (Defines what actually runs)
- **CI Errors Script:** `scripts/check-ci-errors.mjs` (Fetches and displays failed CI error details)
- **CodeQL Status Script:** `scripts/check-codeql-status.mjs` (Checks code scanning alerts)
- **CodeQL Workflow File:** `.github/workflows/codeql.yml` (Defines code scanning configuration)

## Extracted from: tmp-multi-agent/.cursor/rules/security-baseline.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

Enforce least privilege and log all auth failures.
Include rationale and a remediation example.

## Extracted from: tmp-multi-agent/.cursor/rules/scoped-build-hygiene.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

Disallow network calls in unit tests; use fixtures instead.
Keep build artifacts out of git.

## Extracted from: tmp-multi-agent/.cursor/rules/observability-defaults.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

Emit structured logs with request ids and user context.
Prefer sampling for noisy components.

## Extracted from: examples/golden-repo/.cursor/rules/typescript.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# TypeScript Type Safety

Avoid using 'any' type as it defeats TypeScript's type safety. Use 'unknown' for truly unknown types, or define proper interfaces.

## Extracted from: examples/golden-repo/.cursor/rules/testing.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Testing Standards

Add or update tests for any nontrivial change. Use the existing test framework and patterns in this project.

## Test Quality

- Prefer fast, focused unit tests.
- Only use integration or end-to-end tests when necessary.
- Test behavior, not implementation details.
- Keep tests independent and deterministic.
- Use descriptive test names that explain what is being tested.

## Test Design

- Tests should act as executable specs: clear names, simple setups, deterministic assertions.
- Explain why a test is missing if you cannot add one, and call out the risk.
- When fixing a bug, add a regression test that fails before the fix and passes after.
- Aim for test coverage that gives confidence in correctness (target 80%+ for critical code).

## Test Co-location

Place test files next to source files using the `.test.*` or `.spec.*` naming convention:

- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx

## Extracted from: examples/golden-repo/.cursor/rules/security.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Security and Privacy

Never log secrets, tokens, passwords, or personal data.

## Secrets and Configuration

- Use existing secrets/configuration mechanisms (environment variables, secure vaults).
- Never hardcode or commit API keys, passwords, or tokens.
- Keep sensitive data out of version control.

Common patterns to avoid:

- API*KEY = "sk_live*..."
- password: "mypassword123"
- token: "ghp\_..."

## Input Validation

- Validate and sanitize untrusted input (file paths, user input, external data).
- Follow established authentication and authorization patterns.
- Do not bypass security checks.

## Risk Communication

- Call out potential security risks clearly, even if outside the current request.
- Be explicit about what is validated and what is not.

## Extracted from: examples/golden-repo/.cursor/rules/global.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Global Principles

Keep the codebase stable, safe, and maintainable.

Match the existing style, patterns, and conventions in this project. Prefer minimal, targeted changes over large rewrites. Make your reasoning and tradeoffs explicit.

When you are unsure or information is ambiguous, stop and ask for clarification.

## Code Quality

- Keep functions and modules focused. Avoid "god objects" and overly complex functions.
- Use clear, simple code over cleverness.
- Preserve public APIs and existing behavior unless explicitly asked to make breaking changes.
- Avoid unnecessary meta-programming and "magic" that hides control flow or behavior.

## Correctness and Safety

Follow these priorities:

1. Correctness
2. Security and safety
3. Maintainability and clarity
4. Performance

## Change Hygiene

- Prefer small, coherent changes.
- Group related edits together.
- When you touch a file, clean up nearby small issues only if safe and related to the change.
- Use clear commit messages explaining what changed and why.

## Extracted from: examples/golden-repo/.cursor/rules/documentation.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Public API Documentation

Public API exports should include JSDoc comments explaining their purpose and usage. This helps with IDE intellisense and documentation generation.

## Extracted from: examples/golden-repo/.cursor/rules/code-review.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Code Review Standards

TODO comments should be converted to GitHub issues before merging. They often get forgotten in the codebase.

Instead of: // TODO: refactor this
Do: Create issue, then // Issue #123: refactor this

## Extracted from: examples/golden-repo/.cursor/rules/aligntrue.mdc

---

## alwaysApply: true

## AGENTS.md

**Version:** v1
**Generated by:** AlignTrue

This file contains rules and guidance for AI coding agents.## Testing requirements

Every new feature must include unit tests. Test files should be co-located with source files using the .test.ts or .spec.ts naming convention.

Examples:

- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx## Code review standards

TODO comments should be converted to GitHub issues before merging. They often get forgotten in the codebase.

Instead of: // TODO: refactor this
Do: Create issue, then // Issue #123: refactor this## Public API documentation

Public API exports should include JSDoc comments explaining their purpose and usage. This helps with IDE intellisense and documentation generation.## Security practices

Never commit API keys, passwords, or tokens to version control. Use environment variables or secure secret management instead.

Common patterns to avoid:

- API*KEY = "sk_live*..."
- password: "mypassword123"
- token: "ghp\_..."## TypeScript type safety

Avoid using 'any' type as it defeats TypeScript's type safety. Use 'unknown' for truly unknown types, or define proper interfaces.## AlignTrue Rules

This file contains rules and guidance for AI coding agents.

## Extracted from: examples/golden-repo/.cursor/rules/ai-guidance.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# AI Collaboration Guidance

This project assumes all code is AI-edited. Design for safe, cheap future changes.

## Code Structure and Contracts

- Define minimal interfaces and contracts first.
- Add tests second to verify the contract.
- Prefer small modules with explicit contracts.
- Keep functions short and names predictable.
- Minimize side effects and hidden state.

## Explicitness Over Cleverness

- Make structure obvious: organize directories clearly and use descriptive naming.
- Prefer explicit over implicit. Avoid hidden side effects and global mutable state.
- Document contracts and invariants for nontrivial functions, focusing on why, not what.
- Keep changes localized; avoid cross-cutting edits unless refactoring with a plan.
- Use patterns consistently; explain new patterns briefly in code comments.

## Workflow

- Update docs only when behavior changes.
- If rules conflict, raise the conflict and propose a resolution.
- Tighten tests when behavior is ambiguous before making heavy edits.
- If stuck or looping, pause and request reassessment.

## Communication

- State assumptions explicitly.
- Provide actionable details: exact flags, files, and snippets.
- Be direct and honest about limits, risks, and edge cases.
- When you change patterns, explain them briefly for future agents.

## Extracted from: apps/docs/.cursor/rules/web_stack.mdc

---

## description: Web stack guide for Nextra documentation site (auto-applies in apps/docs/)

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Web stack guide

**Applies to:** `apps/docs/` documentation site only

Guide for the Nextra-based AlignTrue docs site: App Router, MDX content, `@aligntrue/ui`, and Vercel deployment. Keep it simple, fast, and boring.

---

## Core principles

1. Use Nextra defaults with minimal custom code.
2. Author content in MDX under `apps/docs/content/`.
3. Use Nextra built-in components where possible.
4. Deploy a single docs site to Vercel at the main domain.
5. Share branding via `@aligntrue/ui`.
6. Prefer changes that stay compatible with Nextra minor upgrades.

---

## Performance and best practices

- Prefer fetching data in RSC (page can still be static)
- Use next/font and next/script when applicable
- next/image above the fold should use `loading="eager"` or `priority` sparingly
- Be mindful of serialized prop size for RSC to child components

---

## Nextra 4.6 App Router setup (critical)

AlignTrue uses Nextra `nextra-theme-docs` with Next.js App Router.

### Theme config

`apps/docs/theme.config.tsx` defines the Nextra theme. Nextra auto-loads this. Do not wire it through `next.config.mjs`.

```tsx
// apps/docs/theme.config.tsx
import { AlignTrueLogo } from "@aligntrue/ui";

const config = {
  logo: <AlignTrueLogo size="md" />,
  project: {
    link: "https://github.com/AlignTrue/aligntrue",
  },
  docsRepositoryBase:
    "https://github.com/AlignTrue/aligntrue/tree/main/apps/docs",
  toc: {
    backToTop: true,
  },
};

export default config;
```

Keep theme config minimal. Complex behavior is handled in the docs layout instead.

### Next.js config

Use Nextra plugin. Do not set theme or themeConfig here. Those are Pages Router only.

```javascript
// apps/docs/next.config.mjs
import nextra from "nextra";

const withNextra = nextra({
  latex: true,
  search: {
    codeblocks: false,
  },
  defaultShowCopyCode: true,
});

export default withNextra({
  output: "export",
  reactStrictMode: true,
  transpilePackages: ["@aligntrue/ui"],
});
```

### App Router layout

Nextra wires most behavior automatically. Use App Router layouts and import Nextra styles in the docs layout only.

**Root layout** (`app/layout.tsx`): Setup SEO, analytics, theming providers. Do NOT import Nextra styles here.

```tsx
// apps/docs/app/layout.tsx (root layout does NOT import Nextra styles)
import type { ReactNode } from "react";
import type { Metadata } from "next";
import { Head } from "nextra/components";
import { ThemeProvider } from "next-themes";
import { Analytics } from "@vercel/analytics/react";

export const metadata: Metadata = {
  title: { default: "AlignTrue", template: "%s – AlignTrue" },
  description:
    "Instantly sync rules across agents, people, projects and teams.",
  // ... additional metadata for SEO, OpenGraph, Twitter
};

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <Head>{/* Analytics and global scripts here */}</Head>
      <body>
        <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
          {children}
          <Analytics />
        </ThemeProvider>
      </body>
    </html>
  );
}
```

**Docs layout** (`app/docs/layout.tsx`): Import Nextra styles and wire theme components.

```tsx
// apps/docs/app/docs/layout.tsx (docs layout imports Nextra styles)
import "nextra-theme-docs/style.css";
import type { ReactNode } from "react";
import { Layout, Navbar } from "nextra-theme-docs";
import { Search } from "nextra/components";
import { getPageMap } from "nextra/page-map";
import themeConfig from "../../theme.config";

export default async function DocsLayout({
  children,
}: {
  children: ReactNode;
}) {
  const pageMap = await getPageMap();
  return (
    <Layout
      pageMap={pageMap}
      navbar={
        <Navbar
          logo={themeConfig.logo}
          projectLink={themeConfig.project.link}
        />
      }
      search={<Search placeholder="Search documentation..." />}
      footer={<DocsFooter />}
      sidebar={{ defaultMenuCollapseLevel: 1, autoCollapse: true }}
    >
      {children}
    </Layout>
  );
}
```

For nested docs layout, use Nextra primitives instead of forking theme config. Wrap, do not reimplement.

### Do not

- Add theme or themeConfig to `nextra()` options.
- Pass a themeConfig prop into `<Layout>`.
- Use legacy `createAlignTrueNextraTheme()` helpers.

If a feature is not in Nextra docs, prefer upgrading Nextra or opening an upstream issue.

---

## Nextra layout and content

### Directory structure

```
apps/docs/
  app/
    layout.tsx                  # Root layout (SEO, analytics, theme provider)
    page.tsx                    # Home page
    docs/
      layout.tsx                # Docs layout (Nextra Layout, styles)
      [[...mdxPath]]/page.tsx   # Dynamic route for all docs pages
  content/
    _meta.js                    # Navigation config
    index.mdx                   # Docs landing
    about.md                    # About page
    00-getting-started/
    01-guides/
    02-customization/
    03-concepts/
    04-reference/
    05-troubleshooting/
    06-development/
    07-contributing/
  mdx-components.tsx            # Shared MDX components
  theme.config.tsx              # Nextra theme config
  next.config.mjs
  vercel.json
```

### Rules

- Use numeric prefixes for content folders: `00-*`, `01-*`, etc.
- Use `index.mdx` or `index.md` for section roots.
- Keep nesting shallow (max 2 levels within a section).
- Navigation comes from `_meta.json` files in each folder.
- Add `about.md` at content root for landing info.

---

## MDX authoring

### Frontmatter

Every page:

```markdown
---
description: Quick intro to AlignTrue
---

# Getting started
```

### Components

Prefer Nextra components. Re-export them in `mdx-components.tsx` for consistency:

```jsx
import { Callout, Cards, Tabs, Steps } from "nextra/components"
import { Mermaid } from "@theguild/remark-mermaid/mermaid";

<Callout type="info">This is informational.</Callout>

<Cards>
  <Cards.Card title="Core" href="/concepts/architecture" />
  <Cards.Card title="CLI" href="/reference/cli" />
</Cards>

<Tabs items={["Option 1", "Option 2"]}>
  <Tabs.Tab>Content for option 1</Tabs.Tab>
  <Tabs.Tab>Content for option 2</Tabs.Tab>
</Tabs>

<Steps>
  ### Step 1
  Do this first
  ### Step 2
  Do this second
</Steps>

<Mermaid>{`graph LR
  A --> B
`}</Mermaid>
```

### Guidelines

- Use semantic MDX, not custom divs.
- Short sections, concrete examples.
- No marketing fluff. Neutral and factual, per documentation standards.

---

## Images and media

- Use `next/image` in MDX.
- Always specify width and height.
- Prefer SVG or small assets.
- No raw `<img>` without dimensions.

```jsx
import Image from "next/image";
import hero from "./hero.png";

<Image src={hero} alt="AlignTrue overview" width={960} height={540} priority />;
```

---

## Performance budgets (docs)

### Per initial route (gzipped)

| Type          | Limit    |
| ------------- | -------- |
| JavaScript    | ≤ 150 KB |
| CSS           | ≤ 50 KB  |
| Single image  | ≤ 200 KB |
| Fonts (total) | ≤ 150 KB |

If a change exceeds a budget, explain in the PR and file a follow up.

### Web vitals targets (mobile p75)

- LCP ≤ 2.5 s
- INP ≤ 200 ms
- CLS ≤ 0.10
- TTFB ≤ 800 ms

Breaking these in production blocks release.

---

## Vercel deployment

Single docs app deployed to `aligntrue.ai`.

### Setup

- Use Vercel Development, Preview, Production envs.
- Never commit `.env*`.
- Client env vars must start with `NEXT_PUBLIC_`.
- Document env usage in `documentation.mdc`.

### Minimal vercel.json

Include security headers and redirects for old URLs. Actual config also includes:

- `buildCommand`, `devCommand`, `installCommand` (explicit commands for reproducibility)
- `framework: "nextjs"` (explicit Next.js framework)
- `regions: ["iad1"]` (specific region for latency)
- Permanent redirects (`301`) for renamed docs pages
- Security headers: `X-Frame-Options`, `X-Content-Type-Options`, `Referrer-Policy`, `Strict-Transport-Security`

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "buildCommand": "pnpm build",
  "framework": "nextjs",
  "redirects": [
    {
      "source": "/quickstart",
      "destination": "/docs/00-getting-started/00-quickstart",
      "permanent": true
    }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "X-Frame-Options", "value": "DENY" },
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}
```

### Each PR

- Must have a Preview URL.
- Must not depend on Production-only secrets.

---

## Logging and analytics

- Use server console logs as structured lines.
- Keep browser logs minimal and non-sensitive.
- If using Vercel Analytics, wire it in `app/layout.tsx` once.
- Configure external log drains only for Production.

---

## Accessibility

- Use `plugin:jsx-a11y/recommended` for docs app.
- All interactive elements keyboard accessible.
- Respect WCAG AA contrast.
- Prefer native semantics, minimal `aria-*`.

Optional Playwright + axe check is encouraged for root and key pages.

---

## Pre merge checks for docs

Run from repo root:

```bash
pnpm lint
pnpm --filter docs build
```

### Optional

```bash
pnpm --filter docs exec playwright test
```

If checks fail on performance or a11y, note it in the PR with a plan.

## Extracted from: tmp-multi-agent/AGENTS.md

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Agent Rules

This file contains links to the canonical rules in `.aligntrue/rules/`.
AI agents should follow these linked guidelines.

How to switch from links to inline rules: https://aligntrue.ai/export-content-mode

## General

- Security Baseline (./.aligntrue/rules/security-baseline.md)
- Observability Defaults (./.aligntrue/rules/observability-defaults.md)
- Scoped Build Hygiene (./.aligntrue/rules/scoped-build-hygiene.md)

## Extracted from: packages/exporters/AGENTS.md

# AGENTS.md

**Version:** v1
**Generated by:** AlignTrue

This file contains rules and guidance for AI coding agents.

<!-- aligntrue:begin {"id":"test-rule"} -->

## Rule: test-rule

**ID:** test-rule
**Severity:** MUST

## <!-- aligntrue:end {"id":"test-rule"} -->

**Generated by AlignTrue**
Content Hash: 80288c1f70e39b253e420dd78d67096eff5f4c61a5f87b38e58a045b3aa66068

**Fidelity Notes:**

- Machine-checkable rules (check) not represented in AGENTS.md format
- Autofix hints not represented in AGENTS.md format

## Extracted from: examples/overlays-demo/AGENTS.md

# AlignTrue Overlays Demo

**Version:** v1
**Generated by:** AlignTrue

This file demonstrates fork-safe customization of upstream rule packs using overlays.

---

## Avoid console.log in production code

Use proper logging library instead of console.log.
Console statements can leak sensitive information and
clutter production logs.

Good: logger.info("User logged in")
Bad: console.log("User logged in")

## Limit cyclomatic complexity

Keep functions simple with cyclomatic complexity under threshold.
Complex functions are hard to test and maintain.

Refactor complex functions into smaller, focused functions.

## Use const for variables that are never reassigned

Use const instead of let for variables that are never reassigned.
This makes code more predictable and prevents accidental reassignment.

Good: const user = getUser();
Bad: let user = getUser();

---

**Generated by AlignTrue**
Content Hash: d41d8cd98f00b204e9800998ecf8427e

## Extracted from: examples/golden-repo/AGENTS.md

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Agent Rules

This file contains links to the canonical rules in `.aligntrue/rules/`.
AI agents should follow these linked guidelines.

How to switch from links to inline rules: https://aligntrue.ai/export-content-mode

## General

- Testing (./.aligntrue/rules/testing.md)
- Security (./.aligntrue/rules/security.md)
- Global (./.aligntrue/rules/global.md)
- Extracted Rules (./.aligntrue/rules/extracted-rules.md)
- Documentation (./.aligntrue/rules/documentation.md)
- Code Review (./.aligntrue/rules/code-review.md)
- AI Guidance (./.aligntrue/rules/ai-guidance.md)

## Extracted from: packages/exporters/temp-test-output/copilot-fidelity/AGENTS.md

# AGENTS.md

**Version:** v1
**Generated by:** AlignTrue

This file contains rules and guidance for AI coding agents.

<!-- aligntrue:begin {"id":"test-rule"} -->

## Rule: test-rule

**ID:** test-rule
**Severity:** MUST

Test rule with check

## <!-- aligntrue:end {"id":"test-rule"} -->

**Generated by AlignTrue**
Content Hash: 615b672f90e281704906cad259a3f639da934b2d03b405f14da520a4507166b2

**Fidelity Notes:**

- Machine-checkable rules (check) not represented in AGENTS.md format
- Autofix hints not represented in AGENTS.md format

## Extracted from: examples/golden-repo/.cursor/rules/extracted-rules.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Extracted Rules

## Extracted from: .cursor/rules/security.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Security and Privacy

Never log secrets, tokens, passwords, or personal data.

## Secrets and Configuration

- Use existing secrets/configuration mechanisms (environment variables, secure vaults).
- Never hardcode or commit API keys, passwords, or tokens.
- Keep sensitive data out of version control.

Common patterns to avoid:

- API*KEY = "sk_live*..."
- password: "mypassword123"
- token: "ghp\_..."

## Input Validation

- Validate and sanitize untrusted input (file paths, user input, external data).
- Follow established authentication and authorization patterns.
- Do not bypass security checks.

## Risk Communication

- Call out potential security risks clearly, even if outside the current request.
- Be explicit about what is validated and what is not.

## Extracted from: .cursor/rules/code-review.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Code Review Standards

TODO comments should be converted to GitHub issues before merging. They often get forgotten in the codebase.

Instead of: // TODO: refactor this
Do: Create issue, then // Issue #123: refactor this

## Extracted from: .cursor/rules/aligntrue.mdc

---

## alwaysApply: true

## AGENTS.md

**Version:** v1
**Generated by:** AlignTrue

This file contains rules and guidance for AI coding agents.## Testing requirements

Every new feature must include unit tests. Test files should be co-located with source files using the .test.ts or .spec.ts naming convention.

Examples:

- src/utils/parser.ts → src/utils/parser.test.ts
- src/components/Button.tsx → src/components/Button.test.tsx## Code review standards

TODO comments should be converted to GitHub issues before merging. They often get forgotten in the codebase.

Instead of: // TODO: refactor this
Do: Create issue, then // Issue #123: refactor this## Public API documentation

Public API exports should include JSDoc comments explaining their purpose and usage. This helps with IDE intellisense and documentation generation.## Security practices

Never commit API keys, passwords, or tokens to version control. Use environment variables or secure secret management instead.

Common patterns to avoid:

- API*KEY = "sk_live*..."
- password: "mypassword123"
- token: "ghp\_..."## TypeScript type safety

Avoid using 'any' type as it defeats TypeScript's type safety. Use 'unknown' for truly unknown types, or define proper interfaces.## AlignTrue Rules

This file contains rules and guidance for AI coding agents.

## Extracted from: .cursor/rules/ai-guidance.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# AI Collaboration Guidance

This project assumes all code is AI-edited. Design for safe, cheap future changes.

## Code Structure and Contracts

- Define minimal interfaces and contracts first.
- Add tests second to verify the contract.
- Prefer small modules with explicit contracts.
- Keep functions short and names predictable.
- Minimize side effects and hidden state.

## Explicitness Over Cleverness

- Make structure obvious: organize directories clearly and use descriptive naming.
- Prefer explicit over implicit. Avoid hidden side effects and global mutable state.
- Document contracts and invariants for nontrivial functions, focusing on why, not what.
- Keep changes localized; avoid cross-cutting edits unless refactoring with a plan.
- Use patterns consistently; explain new patterns briefly in code comments.

## Workflow

- Update docs only when behavior changes.
- If rules conflict, raise the conflict and propose a resolution.
- Tighten tests when behavior is ambiguous before making heavy edits.
- If stuck or looping, pause and request reassessment.

## Communication

- State assumptions explicitly.
- Provide actionable details: exact flags, files, and snippets.
- Be direct and honest about limits, risks, and edge cases.
- When you change patterns, explain them briefly for future agents.

## Extracted from: AGENTS.md

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Agent Rules

This file contains links to the canonical rules in `.aligntrue/rules/`.
AI agents should follow these linked guidelines.

How to switch from links to inline rules: https://aligntrue.ai/export-content-mode

## General

- Testing (./.aligntrue/rules/testing.md)
- Security (./.aligntrue/rules/security.md)
- Global (./.aligntrue/rules/global.md)
- Extracted Rules (./.aligntrue/rules/extracted-rules.md)
- Documentation (./.aligntrue/rules/documentation.md)
- Code Review (./.aligntrue/rules/code-review.md)
- AI Guidance (./.aligntrue/rules/ai-guidance.md)

## Extracted from: .cursor/rules/extracted-rules.mdc

---

## {}

<!--
  READ-ONLY: This file is auto-generated by AlignTrue.
  DO NOT EDIT DIRECTLY. Changes will be overwritten.
  Edit rules in .aligntrue/rules/ instead.
-->

# Extracted Rules
